# ##### BEGIN GPL LICENSE BLOCK #####
#
#  This program is free software; you can redistribute it and/or
#  modify it under the terms of the GNU General Public License
#  as published by the Free Software Foundation; either version 2
#  of the License, or (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software Foundation,
#  Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
#
# ##### END GPL LICENSE BLOCK #####

bl_info = {
	"name": "Piles'N'Tiles",
	"author": "Jesse Sutherland (SynaGl0w)",
	"version": (0, 1),
	"blender": (2, 7, 4),
	"location": "Tool Shelf > Seamless Tab",
	"description": "Seamless tools for blender.",
	"warning": "Work in Progress!",
	"wiki_url": "",
	"tracker_url": "http://blenderartists.org/forum/showthread.php?377518-Addon-Piles-N-Tiles-Seamless-Tools-for-Blender",
	"category": "Object"}

import bpy
from bpy.types import Operator, Panel, PropertyGroup, AddonPreferences
from bpy.props import *
from bgl import *
from mathutils import Vector, Matrix
from collections import defaultdict
from random import seed, random

SEAMLESS_AREA_NAME = "~seamless_area"
SEAMLESS_OBJECTS_NAME = "~seamless_objects"
SEAMLESS_PROXIES_NAME = "~seamless_proxies"
SEAMLESS_MARGIN_NAME = "~seamless_margin"
SEAMLESS_FLOOR_NAME = "~seamless_floor"
SEAMLESS_CAMERA_NAME = "~seamless_camera"
SEAMLESS_PROXY_GROUP = "~sproxies.000"
SEAMLESS_PROXY_NAME = "~sproxy.000"
SEAMLESS_PROXY_PREFIX = "~sproxies"
SEAMLESS_LOC = "seamless_loc"
SEAMLESS_LEVEL = "seamless_level"
SEAMLESS_CLIP = "seamless_clip"

def unpack_node_groups(): # *** Generated by node groups to python packer. Very WIP! ***
	from json import loads;from zlib import decompress;from base64 import b64decode
	groups = (
		"eNrtXFtv4sgSfia/AvEc+nT1vc9bZrM7ipTLKJfRzDlaISc4G84SjMDMZjWa+e2nDfgK3bYxWchlpIwBl9vVVe2q+qqq/f2g1fljEszG086/2/89aLW+m79W"
		"ZzgY/Rn/0mot/m+Jw8URL48Qf58ffj9cRxvTkAq0MQ110EKBB+agJRZaWENLLbRkDS0u0EoHD7JAKxy0rEDL87QHyQWdkffoG+10LoPZqN/+7N+FwaSzPBX0"
		"/VRz3xcjdIbBnRcOglFyotXqUiKQIrFAW12OCMd68W3JWHqnj9EaaZ+MxrOwE5/7a9APH3oPg37fjwbmCglM4gl3ft5F150bdubX5i/9GYwzrNx7w6kf8xFO"
		"Zms/54jmX5aszg8/DsvmyzFiisV6blGBOAPbdM+88CFhNhj7k3i0zuXFzflxcmo29Xt3Q+8xmk2WwaJsKEaYcp6XzdWD1/cnkYRyt/s5MCeXE2l1IPOl1en7"
		"995sGPa+ecNZxGi8VMwpc6/ol0hky99+LI4/dit0zjFP1hhGBDPqEDrCGLYpeGIWJZH6TQpes1Tw5cvdSJ5sVfISacLgzUkeJDWLXCeSB4QZobY1/0vweDsY"
		"+e3Ljx9sdpURmwyXF2evfe4JD6Y97y4cfPN7wSyMLPpC/Id2eRBNkILYLSydmc3BXCwGtUhCaISV4hYPU7h2B6rvKo4Y1lndc0G0TfdX/tgzT9mGyo+v/ie1"
		"v27OoDSiWmRMvFKSScucF7FK2+5fj46PbbIw8QoHYXWii6E3tivxhMwSRYndXP0Sf/69nhmy87ELI5YJJYtSvJ74/jKUnEsvH0fahJaRUv5jYRk8ek/JtYDN"
		"v+TEYJSc6ObO5FdOZ/Xhvwru/vTD5enV+QXVJ3G48sHB/lrWm3N9sFS8A4fxArZiFbBVEbNABWyFHRioiJdIDRxWBwNRBw/MgkehIWbjFh7AQUsKR6iE2dq/"
		"Pjlh2+3QH/V74d/jRZR2c3p98un0a8fhbUEzRFIPJE30K8AacA+ecvF2FNp5w/GDVwztqsZ8dm9lbpVzVDnDjJ2GGfYq4PNu/WE0NfjXyKUHIRGTadTTBWbc"
		"oqiNNo9PPp8c/1o79jZ3E1hvEnu/JFWsCUYEN7FImtMgGoEmG8ciVzcfri+PfrmuH5yti0X2LAY4bGhpTOBnol1QSUIFIwyK2E3Nu5nZwMyceU9OJVDMTVDM"
		"UjsT4X4qNsqwnB19OTm7OauP9AkSlLPtI33DKt57k8MkR0Qklt6AFCoI2TyNKgCRlbzJ/qRRGSAlaTpdhRgF5Zqu0SJLOI7inF4YYYy16etYHNHzSLBFQhIb"
		"I4+tOb35TeuKaFUsz5cRoRgQJDbMxGiaAlZN8iIUKcblrvIi20eTtYAYrMeQTZDYoZNNVQvN5qxYmvu584a+lZnfhoEXVuKlEQCvJriL+/upH74DbwOuWBHl"
		"ueApFDEy8BpAnbuAehGpgwvWSwucrVKuxA5a3CAF4ILUqkaJt0irHbS6RvkaapSOeY3UAhSFplzEzDIyuIihMHKVajfQGikZcCkPVpoEnOIorjdwKRuKqwhE"
		"aYX8yvceh/502r6eeKPpfTB5rFsnlwQRnGSdWwphwShzBtgEb7V2TBBVz1HCzGS29wnydA1jzhSXYIiRtMjCMJKEcbdGSEWEX6O6CYy/62S9TiTiknB3nZ/Q"
		"d5VsB5IRgQ1kTDpbCEVMKukWPtuy8B0pmXwSbNfS6RKGFKiStclfqXjS7LU7rQQG5nOaQFRuZIZLZIbpdlPYyng9+spT2HfB0ICQjBktBUKJBq8HQ7/9xalE"
		"QgVKM0mREiXVtshlugyUeqEZuPdkrcGbQZTdyn6eS3l9yrtEL2KPcnpUI5H6khYFRAl3x3xgiTBWUukv36IWxdMFgbQEt8cB+mbkU0AMUYBKKClxyPAOGZ7T"
		"nRlLyEW2J49gVlIl4e/+rKk/S9wYVPNnX0v8mZGhyNTUTVBiN8t5h/b323ZowphoSOO5LgdjsVWDIpVEVNO97fVnBJDgmek649e4B/fL1/9s3IObvXY3XZhG"
		"oyxNinCKJANW1nnqmHK0RDgVZe2n/+TE65fauAndIO1RiMRi1oFuUmuTBhiB2I8eZCt+KLe3SWK0UN5ZW+JWJp6QIitFSleaDB69JycrUKQfjGrVgFYMuzfx"
		"vV6QZ38ShEX2cdqabBt6Oq/G1WE+jNLJQ+utrHeKwoWFoFY6XxbyyP38bV6lStpyPl2cnFubkaQ2QbaW9gBjPB6M/nhRS/MyVqazA4YRBCK3ODGTei8W56Q4"
		"gbe7PDVFWmC6u+X5+roUXnmxfYNSNDQoReMau4I32L3rLBmX1zF/86Zh+zwYTH13/TK2oceB26UTrRFTqdUUHGETMG7aKXt8cd37dHlxfGNvlgWNIN0K+ny7"
		"d4BFkW+6Z8cYHqFT6GOED4gRopONPJX27OA969ddG6ZRjjKFDsGQNpivEchTaYPv3oG8LgGMILO5WESVHVF/S/fVyXn9fI5BmIwK+ua2t3aBMEQzyV9BDSAq"
		"Kb9bO46fO/lbQ/BSUwFI7rzhO+iXdN0jKTTLih+klhuV5s6MwT692HDpb18D+9mBf3Q7dW70EYjqTIbBGCHMSmpFto32Rx+uLk5vrjdILktECeWvWyP1sz/A"
		"FKIZS0VMJCCgQfIn2trPhX49jdYvedsuboBX8ll9R/d1VbRSp30XN0AKpEZX57aad6EBCiL5BmlXh+bRxPec4KY8pVR8tte1AzGKFE/tdfRIC7dRyMUvuQ0s"
		"tu7SzDYWQowNIsJmuNMHZsfbWBJ/9ymYDsqSbhQbrydTIQKnSHNbDPjRDx79cGItwVER7Y21eq9z/6+VEWpupowZ7ZDKlLQyJatMyStTisqUcs+AaX0vLahE"
		"kElFyOglUbLRfiiFGMfN3XSNx6zKk3Vx+z/j7dqnsQgcMtHm+QKZYnlJDJa3PV/LcU9G94FNIgrPC6C2R2wxQm6APXjC9qUZr457YSCiVy5kLCNDxLofN3Yv"
		"5PW7l/WiotmmHMBIOEuz5btIkxdqZDeSKoU0ZbaQfg6dSEUx5bAT2eH7hJ5ZXeWNqWCr3l3602A4KzNw0VvBOGR0T6LWHovyJ6tDFpsVooq0gO138Ri4t5dv"
		"ZdqPuo/NozXYXPuc7B6Nx5Pgqf3CuF4JyKuV1w7M4cf/AZ9tUMw="
		)
	groups = loads(decompress(b64decode(groups)).decode())["groups"]
	s_c,s_n,s_dv,s_vmi,s_vma,s_i,s_o,s_no,s_li = "~c","name","default_value","min_value","max_value","~i","~o","nodes","links"
	def is_group(d, g):
		i, o = d.get(s_i, []), d.get(s_o, []); b = "|"
		s1 = str(len(i))+b+str(len(o))+b
		for s in i and o: s1 += s[s_c]
		i, o = g.inputs, g.outputs
		s2 = str(len(i))+b+str(len(o))+b
		for s in i and o: s2 += s.bl_socket_idname
		return s1 == s2
	def d2o(d,o,n):
		try: v = d[n]
		except: return
		try: l = len(v)
		except: l = 0
		try:
			if l and isinstance(v, list): setattr(o,n,v[:])
			else: setattr(o,n,v)
		except: pass
	gm = {}
	def _nh_nop(d,o,n): pass
	def _nh_i(d,o,n):
		for k, v in d[n].items():
			try: s = o.inputs[int(k)]
			except: continue
			for a in v: d2o(v,s,a)
	def _nh_o(d,o,n):
		for k, v in d[n].items():
			try: s = o.outputs[int(k)]
			except: continue
			for a in v: d2o(v,s,a)
	def _nh_op(d,o,n): o.mute,o.hide,o.show_options,o.show_preview,o.show_texture = d[n]
	def _nh_tree(d,o,n): o.node_tree = gm[d[n]]
	def _nh_wh(d,o,n): old=o.bl_width_min;o.bl_width_min=0;d2o(d,o,n);o.bl_width_min=old
	def _nh_col(d,o,n): d2o(d,o,n); o.use_custom_color = True
	_nh = {s_c:_nh_nop,s_i:_nh_i,s_o:_nh_o,"~op":_nh_op,"node_tree":_nh_tree,"color":_nh_col,"width_hidden":_nh_wh}
	ngd = bpy.data.node_groups
	for d in groups:
		name = d[s_n]
		try: g = ngd[name]
		except: pass
		else:
			if is_group(d, g): gm[name]=g;continue
		g = ngd.new(name,d[s_c])
		gm[name] = g
		i, o = d.get(s_i, []), d.get(s_o, [])
		gi, go = g.inputs, g.outputs
		for s in i: sk=gi.new(s[s_c],s[s_n]);d2o(s,sk,s_dv);d2o(s,sk,s_vmi);d2o(s,sk,s_vma)
		for s in o: sk=go.new(s[s_c],s[s_n]);d2o(s,sk,s_dv);d2o(s,sk,s_vmi);d2o(s,sk,s_vma)
		nodes, nl = g.nodes, []
		for dn in d[s_no]:
			n = nodes.new(dn[s_c]);n.select=False
			nl.append(n)
			for a in dn:
				try: _nh[a](dn,n,a)
				except: d2o(dn,n,a)
		links = g.links
		for l in d[s_li]:
			try: links.new(nl[l[0]].outputs[l[1]],nl[l[2]].inputs[l[3]])
			except: pass
	for g in gm.values():
		g.use_fake_user = True

# Group Management
def get_group(name, create=False):
	groups = bpy.data.groups
	try:
		group = groups[name]
	except KeyError:
		group = None
		if create:
			group = groups.new(name)
	return group

def get_so_group(create=False):
	return get_group(SEAMLESS_OBJECTS_NAME, create)

def get_sp_group(create=False):
	return get_group(SEAMLESS_PROXIES_NAME, create)

def get_ma_group(create=False):
	return get_group(SEAMLESS_MARGIN_NAME, create)

# Object Management
def get_object(name, context, create=False, setup_callback=None, data=None):
	scene = context.scene
	scene_objects = scene.objects
	try:
		obj = scene_objects[name]
	except KeyError:
		blend_objects = bpy.data.objects
		try:
			obj = blend_objects[name]
		except KeyError:
			obj = None
			if create:
				if callable(data):
					data = data(name, context)
				obj = blend_objects.new(name, data)
				if obj:
					obj.name = name
					if callable(setup_callback):
						setup_callback(obj)
		if obj and create:
			scene_objects.link(obj)
			scene.update()
	return obj

def _get_base(name, scene):
	try:
		return scene.object_bases[name]
	except KeyError:
		scenes = bpy.data.scenes
		for ds in scenes:
			if ds is scene:
				continue
			try:
				return ds.object_bases[name]
			except KeyError:
				continue
	return None

def delete_objects(*args):
	context = bpy.context
	scene = context.scene
	
	objects = []
	selected_bases = []
	for arg in args:
		if isinstance(arg, (list, tuple, set)):
			for obj in arg:
				if not obj:
					continue
				objects.append(obj)
				base = _get_base(obj.name, scene)
				if base: selected_bases.append(base)
		else:
			if not arg:
				continue
			objects.append(arg)
			base = _get_base(arg.name, scene)
			if base: selected_bases.append(base)
	
	if not objects:
		return

	window = context.window
	screen = context.screen
	area = context.area
	region = context.region
	edit_object = context.edit_object
	blend_data = context.blend_data

	override = {
		"active_object": objects[0],
		"object": objects[0],
		"selected_objects": objects,
		"selected_bases": selected_bases,
		"edit_object": edit_object,
		"blend_data": blend_data,
		"window": window,
		"screen": screen,
		"area": area,
		"region": region,
		"scene": scene
	}
	bpy.ops.object.delete(override, use_global=True)

def update_scenes(scenes):
	for scene in scenes:
		scene.update()

def get_seamless_area(context, create=False):
	name = SEAMLESS_AREA_NAME

	def setup(obj):
		obj.empty_draw_type = "SINGLE_ARROW"
		obj.lock_scale = [True, True, True]

	obj = get_object(name, context, create, setup)
	return obj

def get_seamless_sub(name, context, create=False):
	def setup(obj):
		obj.hide = True
		obj.hide_select = True
		obj.lock_scale = [True, True, True]

	obj = get_object(name, context, create, setup)
	if obj and not obj.parent:
		obj.parent = get_seamless_area(context, create)
	return obj

def get_seamless_objects(context, create=False):
	return get_seamless_sub(SEAMLESS_OBJECTS_NAME, context, create)

def get_seamless_proxies(context, create=False):
	return get_seamless_sub(SEAMLESS_PROXIES_NAME, context, create)

def get_seamless_margin(context, create=False):
	return get_seamless_sub(SEAMLESS_MARGIN_NAME, context, create)

def get_seamless_camera(context, create=False):
	name = SEAMLESS_CAMERA_NAME

	def setup(obj):
		obj.location[2] = 32.0
		obj.parent = get_seamless_area(context, True)

	def get_camera_data(name, context):
		cameras = bpy.data.cameras
		try:
			data = cameras[name]
		except KeyError:
			data = cameras.new(name)
			data.name = name
		if data:
			data.type = "ORTHO"
		return data

	obj = get_object(name, context, create, setup, get_camera_data)
	return obj

def get_seamless_margin_obj(suffix, context, create=False):
	name = SEAMLESS_MARGIN_NAME + suffix

	def setup(obj):
		obj.lock_scale = [True, True, True]
		obj.draw_type = "WIRE"

	def get_data(name, context):
		meshes = bpy.data.meshes
		data = meshes.new(name)
		data.name = name
		data.from_pydata(
			[
				(-1, 0, -1),
				(1, 0, -1),
				(1, 0, 1),
				(-1, 0, 1)
			],
			[],
			[(0, 1, 2, 3)]
		)
		data.update()
		return data

	obj = get_object(name, context, create, setup, get_data)
	if obj:
		obj.parent = get_seamless_margin(context, create)
		if create and not obj.rigid_body:
			obj.hide = False
			obj.hide_select = False
			obj.hide_render = False

			window = context.window
			screen = context.screen
			area = context.area
			region = context.region
			scene = context.scene
			override = {
				"active_object": obj,
				"object": obj,
				"selected_objects": [obj,],
				"window": window,
				"screen": screen,
				"area": area,
				"region": region,
				"scene": scene
			}
			bpy.ops.rigidbody.objects_add(override, type="PASSIVE")
			rb = obj.rigid_body
			rb.collision_shape = "BOX"
			rb.use_margin = True
			rb.collision_margin = 1.0

			obj.hide = True
			obj.hide_select = True
			obj.hide_render = True

	return obj

def get_seamless_floor_obj(context, create=False):
	name = SEAMLESS_FLOOR_NAME

	def setup(obj):
		obj.lock_scale = [True, True, True]
		obj.draw_type = "WIRE"

	def get_data(name, context):
		meshes = bpy.data.meshes
		data = meshes.new(name)
		data.name = name
		data.from_pydata(
			[
				(-1, -1, 0),
				(1, -1, 0),
				(1, 1, 0),
				(-1, 1, 0)
			],
			[],
			[(0, 1, 2, 3)]
		)
		data.update()
		return data

	obj = get_object(name, context, create, setup, get_data)
	if obj:
		obj.parent = get_seamless_area(context, create)
		if create and not obj.rigid_body:
			obj.hide = False
			obj.hide_select = False
			obj.hide_render = False

			window = context.window
			screen = context.screen
			area = context.area
			region = context.region
			scene = context.scene
			override = {
				"active_object": obj,
				"object": obj,
				"selected_objects": [obj,],
				"window": window,
				"screen": screen,
				"area": area,
				"region": region,
				"scene": scene
			}
			bpy.ops.rigidbody.objects_add(override, type="PASSIVE")
			rb = obj.rigid_body
			rb.collision_shape = "BOX"
			rb.use_margin = True
			rb.collision_margin = 0.5

			obj.hide = True
			obj.hide_select = True
			obj.hide_render = True

	return obj

def copy_rb_settings_to_proxy(obj, proxy):
	rbs = obj.rigid_body
	rbd = proxy.rigid_body

	rbd.type = "PASSIVE"
	rbd.collision_shape = rbs.collision_shape
	rbd.collision_margin = rbs.collision_margin
	rbd.collision_groups[:] = rbs.collision_groups
	rbd.use_margin = rbs.use_margin
	rbd.friction = rbs.friction
	rbd.restitution = rbs.restitution
	rbd.mesh_source = rbs.mesh_source
	rbd.use_deform = rbs.use_deform
	rbd.kinematic = True if rbs.type == "ACTIVE" else rbs.kinematic

# Node Group Updates
def update_node_groups(props, context):
	g = bpy.data.node_groups
	try: tx = g["Seamless Transform"].nodes
	except: return
	try: tx["seamless_tile_x"].outputs[0].default_value = props.tile_x
	except: pass
	try: tx["seamless_tile_y"].outputs[0].default_value = props.tile_y
	except: pass
	sa = get_seamless_area(context)
	if not sa: return
	try: offset = tx["seamless_area_offset"]
	except: pass
	else: offset.translation[:] = sa.location; offset.translation.negate()
	try: rot = tx["seamless_area_rotation"]
	except: pass
	else: rot.rotation[:] = sa.matrix_world.inverted().to_euler()
		

# Property Updates
def update_camera(self, context):
	camera = get_seamless_camera(context)
	if not camera:
		return

	camera.data.ortho_scale = max(self.tile_x, self.tile_y)

	scene = context.scene

	if self.res_mode == "MIN":
		min_res = self.min_res
		x = round((self.tile_x / self.tile_y) * min_res)
		y = round((self.tile_y / self.tile_x) * min_res)
		if x < y:
			scene.render.resolution_x = min_res
			scene.render.resolution_y = y
		else:
			scene.render.resolution_x = x
			scene.render.resolution_y = min_res
	else:
		max_res = self.max_res
		x = round((self.tile_x / self.tile_y) * max_res)
		y = round((self.tile_y / self.tile_x) * max_res)
		if x < y:
			scene.render.resolution_x = x
			scene.render.resolution_y = max_res
		else:
			scene.render.resolution_x = max_res
			scene.render.resolution_y = y

def update_proxy_location(step, index):
	sp_group = get_sp_group()
	if sp_group:
		sp_objects = sp_group.objects
		for obj in sp_objects:
			loc = obj.get(SEAMLESS_LOC, [])
			if len(loc) != 2:
				continue
			obj.location[index] = step * loc[index]

def update_tile_x(self, context):
	update_camera(self, context)
	update_proxy_location(self.tile_x, 0)
	update_margin(self, context)
	update_node_groups(self, context)

def update_tile_y(self, context):
	update_camera(self, context)
	update_proxy_location(self.tile_y, 1)
	update_margin(self, context)
	update_node_groups(self, context)

def update_margin(self, context):
	use_margin = self.use_margin
	ma = get_seamless_margin_obj("_a", context, use_margin)
	mb = get_seamless_margin_obj("_b", context, use_margin)
	mc = get_seamless_margin_obj("_c", context, use_margin)
	md = get_seamless_margin_obj("_d", context, use_margin)
	if use_margin:
		ma.rotation_euler[2] = 0.0
		mb.rotation_euler[2] = 4.7123891115188598
		mc.rotation_euler[2] = 3.1415927410125732
		md.rotation_euler[2] = 1.5707963705062866

		margin = self.margin
		x = float(self.tile_x)
		y = float(self.tile_y)
		hx = x / 2.0
		hy = y / 2.0
		z = 1024.0

		ma.location[1] = hy + margin
		mb.location[0] = hx + margin
		mc.location[1] = -(hy + margin)
		md.location[0] = -(hx + margin)

		ac = [(-(hx + margin), 0, -z), (hx + margin, 0, -z), (hx + margin, 0, z), (-(hx + margin), 0, z)]
		bd = [(-(hy + margin), 0, -z), (hy + margin, 0, -z), (hy + margin, 0, z), (-(hy + margin), 0, z)]
	
		for index, vert in enumerate(ma.data.vertices):
			vert.co = Vector(ac[index])

		for index, vert in enumerate(mb.data.vertices):
			vert.co = Vector(bd[index])

		for index, vert in enumerate(mc.data.vertices):
			vert.co = Vector(ac[index])

		for index, vert in enumerate(md.data.vertices):
			vert.co = Vector(bd[index])

		ma.data.update()
		mb.data.update()
		mc.data.update()
		md.data.update()
	else:
		delete_objects(ma, mb, mc, md)

	update_floor(self, context)

def update_floor(self, context):
	use_floor = self.use_floor
	floor_obj = get_seamless_floor_obj(context, use_floor)
	
	if use_floor:
		floor = self.floor
		margin = self.margin if self.use_margin else 0
		x = float(self.tile_x)
		y = float(self.tile_y)
		hx = x / 2.0
		hy = y / 2.0
		
		floor_obj.location[2] = floor

		points = [(-(hx + margin), -(hy + margin), 0), (hx + margin, -(hy + margin), 0), (hx + margin, hy + margin, 0), (-(hx + margin), hy + margin, 0)]
		for index, vert in enumerate(floor_obj.data.vertices):
			vert.co = Vector(points[index])

		floor_obj.data.update()
	else:
		delete_objects(floor_obj)

# Operators
class ObjectMode:
	bl_options = {'REGISTER', 'UNDO'}
	
	@classmethod
	def poll(cls, context):
		return context.mode == "OBJECT" and context.space_data.type == "VIEW_3D"

class ObjectModeSeamless:
	bl_options = {'REGISTER', 'UNDO'}
	
	@classmethod
	def poll(cls, context):
		return context.mode == "OBJECT" and context.space_data.type == "VIEW_3D" and get_seamless_area(context)

class Box:
	def __init__(self, width, height, x, y):
		self.hx = width / 2.0
		self.hy = height / 2.0
		self.x = x
		self.y = y

	def __call__(self, box):
		x = abs(self.x - box.x) <= (self.hx + box.hx)
		y = abs(self.y - box.y) <= (self.hy + box.hy)
		return x and y

	def dist(self, box):
		x = abs(self.x - box.x)
		y = abs(self.y - box.y)
		return x, y

class SeamlessProxyManager:
	def sproxy_begin(self, context):
		self._sp_unlink_groups = defaultdict(set)
		self._sp_deletion = set()
		self._sp_link_scenes = defaultdict(set)
		self._sp_link_groups = defaultdict(set)
		self._sp_rb_settings = defaultdict(set)
		self._sp_rb_add = set()
		self._sp_rb_remove = set()
		self._rbg = context.scene.rigidbody_world.group if context.scene.rigidbody_world else None
		props = context.scene.seamless
		margin = props.margin if props.use_margin else 0
		margin *= 2.0
		self._box = Box(props.tile_x + margin, props.tile_y + margin, 0, 0)
		self._box_sa = Box(props.tile_x, props.tile_y, 0, 0)
		self.optimize = props.optimize

	def sproxy_update_object(self, obj, proxy, parent, group, scene, props):
		proxy_objects = group.objects
		scene_objects = scene.objects
		location = proxy.get(SEAMLESS_LOC, [])
		if len(location) != 2:
			raise RuntimeError("Seamless proxy object to be updated has no location information.")
		
		if proxy.name not in scene_objects:
			self._sp_link_scenes[scene].add(proxy)
		if proxy.name not in proxy_objects:
			self._sp_link_groups[group].add(proxy)
		if proxy.parent != parent:
			proxy.parent = parent

		proxy.location[0] = props.tile_x * location[0]
		proxy.location[1] = props.tile_y * location[1]
		proxy.location[2] = 0

		# Check constraints
		const = proxy.constraints
		# Verify constraints?
		if not const:
			con_scale = const.new("COPY_SCALE")
			con_scale.name = "proxy_scale"
			con_scale.target_space = "LOCAL"
			con_scale.owner_space = "LOCAL"
			con_scale.target = obj
			con_scale.show_expanded = False

			con_rot = const.new("COPY_ROTATION")
			con_rot.name = "proxy_rotation"
			con_rot.target_space = "WORLD"
			con_rot.owner_space = "WORLD"
			con_rot.target = obj
			con_rot.show_expanded = False

			con_loc = const.new("COPY_LOCATION")
			con_loc.name = "proxy_location"
			con_loc.target_space = "LOCAL"
			con_loc.owner_space = "LOCAL"
			con_loc.use_offset = True
			con_loc.target = obj
			con_loc.show_expanded = False

		# Check rigid body
		if obj.rigid_body and not proxy.rigid_body:
			self._sp_rb_settings[obj].add(proxy)
			self._sp_rb_add.add(proxy)
		elif proxy.rigid_body and not obj.rigid_body:
			self._sp_rb_remove.add(proxy)
		elif obj.rigid_body and proxy.rigid_body:
			copy_rb_settings_to_proxy(obj, proxy)

	def sproxy_update(self, obj, proxy_parent, proxy_group, scene, props):
		# Get proxy groups if any
		sproxy_groups = []
		for group in obj.users_group:
			if group.name.startswith(SEAMLESS_PROXY_PREFIX):
				sproxy_groups.append(group)

		# Proxy group selection and preprocessing
		sp_unlink_groups = self._sp_unlink_groups
		sp_group = None
		for group in sproxy_groups:
			gobs = group.objects
			unlinks = sp_unlink_groups[group]
			if sp_group:
				for gob in gobs:
					if gob == obj:
						unlinks.add(gob)
						continue
					try:
						target = gob.constraints[0].target
					except:
						continue
					if not target:
						continue

					if target == obj:
						unlinks.add(gob)
			else:
				in_group = []
				out_group = []
				for gob in gobs:
					if gob == obj:
						in_group.append(gob)
						continue
					try:
						target = gob.constraints[0].target
					except:
						out_group.append(gob)
						continue
					if not target:
						continue

					if target == obj:
						in_group.append(gob)
					else:
						out_group.append(gob)
			
				if len(in_group) <= len(out_group):
					for o in in_group:
						unlinks.add(o)
				else:
					for o in out_group:
						unlinks.add(o)
					sp_group = group
		
		# Make a new group if one was not resolved above
		if not sp_group:
			sp_group = bpy.data.groups.new(SEAMLESS_PROXY_GROUP)
			self._sp_link_groups[sp_group].add(obj)

		# Make proxy dict
		gobs = sp_group.objects
		proxies = defaultdict(list)
		for gob in gobs:
			try:
				loc = gob[SEAMLESS_LOC]
			except KeyError:
				continue
			try:
				proxies[tuple(loc)].append(gob)
			except:
				pass

		# Get proxy level
		level = obj.get(SEAMLESS_LEVEL, 1)

		# Get clipping state
		clip = obj.get(SEAMLESS_CLIP, False)
		if obj.rigid_body:
			if obj.rigid_body.type == "ACTIVE":
				clip = False
		if clip or self.optimize:
			matb = obj.matrix_basis
			bb = [matb * Vector(vert) for vert in obj.bound_box]
			bbx_min = bbx_max = bb[0][0]
			bby_min = bby_max = bb[0][1]
			for vert in bb:
				x = vert[0]
				y = vert[1]
				bbx_min = min(bbx_min, x)
				bbx_max = max(bbx_max, x)
				bby_min = min(bby_min, y)
				bby_max = max(bby_max, y)

			bb_w = abs(bbx_max - bbx_min)
			bb_h = abs(bby_max - bby_min)
			bb_x = bbx_min + (bb_w / 2.0)
			bb_y = bby_min + (bb_h / 2.0)

		# Mark duplicate proxies for deletion
		deleted = self._sp_deletion
		for value in proxies.values():
			for i, p in enumerate(value):
				if i > 0:
					deleted.add(p)

		# Mark out-of-level proxies for deletion
		for key, value in proxies.items():
			if abs(key[0]) > level or abs(key[1]) > level or (key[0] != 0 and not props.use_tile_x) or (key[1] != 0 and not props.use_tile_y):
				for p in value:
					deleted.add(p)

		# Optimize?
		if self.optimize:
			obj_x, obj_y = self._box_sa.dist(Box(bb_w, bb_h, bb_x, bb_y))
			old_x = obj.location[0]
			old_y = obj.location[1]
			x = -level
			while x <= level:
				y = -level
				while y <= level:
					if x == 0 and y == 0:
						y += 1
						continue
					proxy = proxies[(x, y)]
					p_x, p_y = self._box_sa.dist(Box(bb_w, bb_h, bb_x + (props.tile_x * x), bb_y + (props.tile_y * y)))
					if p_x < obj_x and props.use_tile_x:
						obj.location[0] = old_x + props.tile_x * x
					if p_y < obj_y and props.use_tile_y:
						obj.location[1] = old_y + props.tile_y * y
					y += 1
				x += 1

			if clip:
				matb = obj.matrix_basis
				bb = [matb * Vector(vert) for vert in obj.bound_box]
				bbx_min = bbx_max = bb[0][0]
				bby_min = bby_max = bb[0][1]
				for vert in bb:
					x = vert[0]
					y = vert[1]
					bbx_min = min(bbx_min, x)
					bbx_max = max(bbx_max, x)
					bby_min = min(bby_min, y)
					bby_max = max(bby_max, y)

				bb_w = abs(bbx_max - bbx_min)
				bb_h = abs(bby_max - bby_min)
				bb_x = bbx_min + (bb_w / 2.0)
				bb_y = bby_min + (bb_h / 2.0)

		# Particle systems?
		use_psys = props.psys
		if hasattr(obj, "particle_systems"):
			obj["skip_psys"] = not use_psys

		# Update proxies
		rbg = self._rbg
		x = -level
		while x <= level:
			y = -level
			while y <= level:
				if x == 0 and y == 0:
					y += 1
					continue
				if (x != 0 and not props.use_tile_x) or (y != 0 and not props.use_tile_y):
					y += 1
					continue
				proxy = proxies[(x, y)]
				if clip:
					if not self._box(Box(bb_w, bb_h, bb_x + (props.tile_x * x), bb_y + (props.tile_y * y))):
						if proxy:
							deleted.add(proxy[0])
						y += 1
						continue
				if proxy:
					p = proxy[0]
				else:
					p = obj.copy()
					p.constraints.clear()
					p.name = SEAMLESS_PROXY_NAME
					p[SEAMLESS_LOC] = [x, y]
					p.select = False
					p.hide = props.default_hide
					p.hide_select = props.default_hide_select
					p.hide_render = props.default_hide_render
					p.draw_type = props.default_draw_type
					try: # *sigh* It really is this simple:
						p.show_wire_color = True
						p.color[0] = p.color[1] = p.color[2] = 0.8
					except:
						pass # *double sigh*
					proxy.append(p)
					self._sp_link_groups[sp_group].add(p)
					if p.rigid_body and rbg:
						self._sp_link_groups[rbg].add(p)

					# Handle particle systems
					if use_psys:
						remove_psys = set()
						if hasattr(p, "particle_systems"):
							for pi, ps in enumerate(p.particle_systems):
								settings = ps.settings
								if not settings:
									continue
								sps = settings.seamless
								sps.mode_last = sps.mode
								if sps.mode == "NONE":
									continue
								elif sps.mode == "REMOVE":
									remove_psys.add(ps)
									continue
								elif sps.mode == "LINKED":
									ps.settings.use_emit_random = False
								elif sps.mode == "DUPLICATE":
									ps.settings = settings = settings.copy()
									settings.name = p.name + ".{0:03d}".format(pi)
									settings.seamless.is_proxy = True
								fc = ps.driver_add("seed")
								driver = fc.driver
								driver.type = "SUM"
								driver_var = driver.variables.new()
								driver_var.name = ps.name
								dt = driver_var.targets[0]
								dt.data_path = "particle_systems[{}].seed".format(pi)
								dt.id = obj
						if remove_psys:
							psys_mods = [mod for mod in p.modifiers if hasattr(mod, "particle_system")]
							for mod in psys_mods:
								if mod.particle_system in remove_psys:
									p.modifiers.remove(mod)
					else:
						if hasattr(obj, "modifiers"):
							psys_mods = [mod for mod in p.modifiers if hasattr(mod, "particle_system")]
							for mod in psys_mods:
								p.modifiers.remove(mod)

				self.sproxy_update_object(obj, p, proxy_parent, proxy_group, scene, props)
				y += 1
			x += 1

	def sproxy_end(self, context):
		sp_link_scenes = self._sp_link_scenes
		for scene, objects in sp_link_scenes.items():
			scene_objects = scene.objects
			for object in objects:
				scene_objects.link(object)
		sp_link_scenes.clear()

		sp_link_groups = self._sp_link_groups
		for group, objects in sp_link_groups.items():
			group_objects = group.objects
			for object in objects:
				group_objects.link(object)
		sp_link_groups.clear()

		sp_unlink_groups = self._sp_unlink_groups
		for group, objects in sp_unlink_groups.items():
			group_objects = group.objects
			for object in objects:
				group_objects.unlink(object)
		sp_unlink_groups.clear()

		delete_objects(self._sp_deletion)
		self._sp_deletion.clear()

		sp_rb_add = list(self._sp_rb_add)
		sp_rb_add_hide = [object.hide for object in sp_rb_add]
		for object in sp_rb_add:
			object.hide = False
		if sp_rb_add:
			window = context.window
			screen = context.screen
			area = context.area
			region = context.region
			scene = context.scene
			override = {
				"active_object": sp_rb_add[0],
				"object": sp_rb_add[0],
				"selected_objects": sp_rb_add,
				"window": window,
				"screen": screen,
				"area": area,
				"region": region,
				"scene": scene
			}
			bpy.ops.rigidbody.objects_add(override, type="PASSIVE")
		for index, object in enumerate(sp_rb_add):
			object.hide = sp_rb_add_hide[index]
		self._sp_rb_add.clear()
		sp_rb_add.clear()

		sp_rb_settings = self._sp_rb_settings
		for object, proxies in sp_rb_settings.items():
			for proxy in proxies:
				copy_rb_settings_to_proxy(object, proxy)
		sp_rb_settings.clear()

		sp_rb_remove = list(self._sp_rb_remove)
		if sp_rb_remove:
			window = context.window
			screen = context.screen
			area = context.area
			region = context.region
			scene = context.scene
			override = {
				"active_object": sp_rb_remove[0],
				"object": sp_rb_remove[0],
				"selected_objects": sp_rb_remove,
				"window": window,
				"screen": screen,
				"area": area,
				"region": region,
				"scene": scene
			}
			bpy.ops.rigidbody.objects_remove(override)
		self._sp_rb_remove.clear()
		sp_rb_remove.clear()

		particles = bpy.data.particles
		sp_psys_remove = [p for p in particles if not p.users and p.seamless.is_proxy]
		for p in sp_psys_remove:
			particles.remove(p)

class SeamlessOperator_Add(Operator, ObjectMode, SeamlessProxyManager):
	"""Add selected objects to the seamless area."""
	bl_idname = "seamless.add"
	bl_label = "Add Seamless"

	def execute(self, context):
		selected = context.selected_objects
		if not selected:
			self.report({'WARNING'}, "Nothing selected!")
			return {'CANCELLED'}

		scene = context.scene
		props = scene.seamless
		wm = context.window_manager

		s_obj = get_seamless_objects(context, True)
		s_prox = get_seamless_proxies(context, True)
		so_group = get_so_group(True)
		sp_group = get_sp_group(True)

		update_margin(props, context)

		seamless_objects = so_group.objects
		self.sproxy_begin(context)
		so_links = self._sp_link_groups[so_group]
		
		count = 0
		total = len(selected)
		
		wm.progress_begin(0, total)
		for obj in selected:
			count += 1
			wm.progress_update(count)
			name = obj.name

			# obj is not a managed object
			if name.startswith("~"):
				continue

			# obj is not a camera
			if obj.type == "CAMERA":
				continue

			# obj is not a proxy (in case proxy does not start with ~)
			try:
				_loc = obj[SEAMLESS_LOC]
			except KeyError:
				pass
			else:
				continue

			# Put in seamless objects group
			if name not in seamless_objects:
				so_links.add(obj)

			# Parent to seamless objects
			if obj.parent != s_obj:
				obj.matrix_world = s_obj.matrix_world.inverted() * obj.matrix_world
				obj.parent = s_obj


			# Assign proxy level
			obj[SEAMLESS_LEVEL] = props.level

			# Assign clipping state
			obj[SEAMLESS_CLIP] = props.clip

			# Update proxies
			self.sproxy_update(obj, s_prox, sp_group, scene, props)

		self.sproxy_end(context)
		wm.progress_end()
		return {'FINISHED'}

class SeamlessOperator_Remove(Operator, ObjectModeSeamless, SeamlessProxyManager):
	"""Remove selected objects from the seamless area."""
	bl_idname = "seamless.remove"
	bl_label = "Remove Seamless"

	def execute(self, context):
		selected = context.selected_objects
		if not selected:
			self.report({'WARNING'}, "Nothing selected!")
			return {'CANCELLED'}
		self.sproxy_begin(context)
		
		sp_deletion = self._sp_deletion
		sp_unlink_groups = self._sp_unlink_groups

		so_group = get_so_group()

		for obj in selected:
			# obj is not a proxy
			try:
				_loc = obj[SEAMLESS_LOC]
			except KeyError:
				pass
			else:
				continue

			if so_group:
				if obj.name in so_group.objects:
					sp_unlink_groups[so_group].add(obj)

			sproxy_groups = []
			for group in obj.users_group:
				if group.name.startswith(SEAMLESS_PROXY_PREFIX):
					sproxy_groups.append(group)
			for group in sproxy_groups:
				gobs = group.objects
				for gob in gobs:
					if gob == obj:
						continue
					try:
						target = gob.constraints[0].target
					except:
						continue
					if not target:
						continue
					if target == obj:
						sp_deletion.add(gob)

			groups = bpy.data.groups
			for group in sproxy_groups:
				groups.remove(group)

			if obj.parent:
				mat = obj.matrix_world
				if obj.parent.name == SEAMLESS_OBJECTS_NAME:
					obj.parent = None
				obj.matrix_world = mat

		self.sproxy_end(context)
		return {'FINISHED'}

class SeamlessOperator_Refresh(Operator, ObjectModeSeamless, SeamlessProxyManager):
	"""Refresh all seamless objects and dependencies."""
	bl_idname = "seamless.refresh"
	bl_label = "Refresh Seamless"

	selected = BoolProperty(
		name="Selected",
		description="Only refresh selected seamless objects.",
		default=False
		)

	def execute(self, context):
		so_group = get_so_group()
		if not so_group:
			return {'CANCELLED'}

		seamless_objects = so_group.objects

		self.sproxy_begin(context)
		scene = context.scene
		props = scene.seamless
		wm = context.window_manager

		s_obj = get_seamless_objects(context, True)
		s_prox = get_seamless_proxies(context, True)
		sp_group = get_sp_group(True)

		sp_deletion = self._sp_deletion
		seamless_proxies = sp_group.objects
		count = 0
		total = len(seamless_proxies)
		
		wm.progress_begin(0, total)
		for obj in seamless_proxies:
			count += 1
			wm.progress_update(count)
			
			try:
				target = obj.constraints[0].target
			except:
				sp_deletion.add(obj)
				continue

			if target:
				valid_sproxy = False
				for group in obj.users_group:
					if group.name.startswith(SEAMLESS_PROXY_PREFIX):
						valid_sproxy = True
						break
				if not valid_sproxy:
					sp_deletion.add(obj)
			else:
				sp_deletion.add(obj)

		if self.selected:
			seamless_objects = [obj for obj in seamless_objects if obj.select]
		
		wm.progress_end()
		count = 0
		total = len(seamless_objects)
		wm.progress_begin(0, total)
		for obj in seamless_objects:
			count += 1
			wm.progress_update(count)
			name = obj.name

			# obj is not a managed object
			if name.startswith("~"):
				continue

			# obj is not a camera
			if obj.type == "CAMERA":
				continue

			# obj is not a proxy (in case proxy does not start with ~)
			try:
				_loc = obj[SEAMLESS_LOC]
			except KeyError:
				pass
			else:
				continue

			# Parent to seamless objects
			if obj.parent != s_obj:
				obj.matrix_world = s_obj.matrix_world.inverted() * obj.matrix_world
				obj.parent = s_obj

			# Update proxies
			self.sproxy_update(obj, s_prox, sp_group, scene, props)

		self.sproxy_end(context)
		wm.progress_end()

		return {'FINISHED'}

class SeamlessOperator_Select(Operator, ObjectModeSeamless):
	"""Select all seamless objects."""
	bl_idname = "seamless.select"
	bl_label = "Select Seamless"

	extend = BoolProperty(
		name="Extend",
		description="Extend existing selection.",
		default=True
		)

	def execute(self, context):
		so_group = get_so_group()
		if not so_group:
			return {'CANCELLED'}

		seamless_objects = so_group.objects
		if len(seamless_objects) < 1:
			return {'CANCELLED'}

		if not self.extend:
			bpy.ops.object.select_all(action="DESELECT")

		for obj in seamless_objects:
			obj.select = True

		return {'FINISHED'}

class SeamlessOperator_Deselect(Operator, ObjectModeSeamless):
	"""Deselect seamless objects."""
	bl_idname = "seamless.deselect"
	bl_label = "Deselect Seamless"

	def execute(self, context):
		so_group = get_so_group()
		if not so_group:
			return {'CANCELLED'}

		seamless_objects = so_group.objects
		if len(seamless_objects) < 1:
			return {'CANCELLED'}

		for obj in seamless_objects:
			obj.select = False

		return {'FINISHED'}

class SeamlessOperator_InvertSelection(Operator, ObjectModeSeamless):
	"""Invert selection of seamless objects."""
	bl_idname = "seamless.invert_selection"
	bl_label = "Invert Seamless Selection"

	def execute(self, context):
		so_group = get_so_group()
		if not so_group:
			return {'CANCELLED'}

		seamless_objects = so_group.objects
		if len(seamless_objects) < 1:
			return {'CANCELLED'}

		for obj in seamless_objects:
			obj.select = not obj.select

		return {'FINISHED'}

class SeamlessOperator_SelectSeamlessArea(Operator, ObjectModeSeamless):
	"""Selects the seamless area (the root object for all that is seamless)"""
	bl_idname = "seamless.select_area"
	bl_label = "Select Seamless Area"

	def execute(self, context):
		sa = get_seamless_area(context)
		if not sa:
			self.report({'WARNING'}, "Seamless area not found!")
			return {'CANCELLED'}

		bpy.ops.object.select_all(action="DESELECT")
		sa.select = True
		context.scene.objects.active = sa

		return {'FINISHED'}

class SeamlessOperator_CursorToSeamlessArea(Operator, ObjectModeSeamless):
	"""Snap 3D cursor to seamless area."""
	bl_idname = "seamless.cursor_to_seamless"
	bl_label = "Cursor to Seamless Area"

	def execute(self, context):
		sa = get_seamless_area(context)
		if not sa:
			self.report({'WARNING'}, "Seamless area not found!")
			return {'CANCELLED'}

		bpy.context.space_data.cursor_location[:] = sa.matrix_world.translation

		return {'FINISHED'}

class SeamlessOperator_ApplyVisualTransform(Operator, ObjectModeSeamless):
	"""Apply visual transform of seamless objects."""
	bl_idname = "seamless.apply_visual_transform"
	bl_label = "Apply Seamless Visual Transform"

	selected = BoolProperty(
		name="Selected",
		description="Only apply visual transform to selected seamless objects.",
		default=False
		)

	def execute(self, context):
		so_group = get_so_group()
		if not so_group:
			return {'CANCELLED'}

		seamless_objects = so_group.objects
		if self.selected:
			seamless_objects = [obj for obj in seamless_objects if obj.select]
		if len(seamless_objects) < 1:
			return {'CANCELLED'}

		window = context.window
		screen = context.screen
		area = context.area
		region = context.region
		scene = context.scene
		override = {
			"active_object":seamless_objects[0],
			"object": seamless_objects[0],
			"selected_objects": seamless_objects,
			"selected_editable_objects": seamless_objects,
			"window": window,
			"screen": screen,
			"area": area,
			"region": region,
			"scene": scene
		}
		bpy.ops.object.visual_transform_apply(override)

		return {'FINISHED'}

class SeamlessOperator_ActiveToPassive(Operator, ObjectModeSeamless):
	"""Change any active rigid body seamless objects to passive."""
	bl_idname = "seamless.active_to_passive"
	bl_label = "Active Seamless to Passive"

	selected = BoolProperty(
		name="Selected",
		description="Only convert selected active seamless objects to passive.",
		default=False
		)

	def execute(self, context):
		so_group = get_so_group()
		if not so_group:
			return {'CANCELLED'}

		seamless_objects = so_group.objects
		if self.selected:
			seamless_objects = [obj for obj in seamless_objects if obj.select]
		if len(seamless_objects) < 1:
			return {'CANCELLED'}

		for obj in seamless_objects:
			if obj.rigid_body:
				obj.rigid_body.type = "PASSIVE"
			else:
				continue

			sproxy_groups = []
			for group in obj.users_group:
				if group.name.startswith(SEAMLESS_PROXY_PREFIX):
					sproxy_groups.append(group)

			for group in sproxy_groups:
				for proxy in group.objects:
					if proxy == obj or not proxy.name.startswith("~"):
						continue
					if obj.rigid_body and proxy.rigid_body:
						copy_rb_settings_to_proxy(obj, proxy)

		return {'FINISHED'}

class SeamlessOperator_Clip(Operator, ObjectModeSeamless, SeamlessProxyManager):
	"""Set clipping state of seamless objects."""
	bl_idname = "seamless.clip"
	bl_label = "Set Seamless Clipping"

	selected = BoolProperty(
		name="Selected",
		description="Only set clip state of selected seamless objects.",
		default=False
		)

	clip = BoolProperty(
		name="Clip",
		description="Enable clipping on seamless objects.",
		default=True
		)

	def execute(self, context):
		so_group = get_so_group()
		if not so_group:
			return {'CANCELLED'}

		seamless_objects = so_group.objects
		if len(seamless_objects) < 1:
			return {'CANCELLED'}

		self.sproxy_begin(context)
		scene = context.scene
		props = scene.seamless
		wm = context.window_manager

		s_obj = get_seamless_objects(context, True)
		s_prox = get_seamless_proxies(context, True)
		sp_group = get_sp_group(True)

		if self.selected:
			seamless_objects = [obj for obj in seamless_objects if obj.select]
		
		count = 0
		total = len(seamless_objects)
		
		wm.progress_begin(0, total)
		for obj in seamless_objects:
			count += 1
			wm.progress_update(count)
			name = obj.name

			# obj is not a managed object
			if name.startswith("~"):
				continue

			# obj is not a camera
			if obj.type == "CAMERA":
				continue

			# obj is not a proxy (in case proxy does not start with ~)
			try:
				_loc = obj[SEAMLESS_LOC]
			except KeyError:
				pass
			else:
				continue

			# Parent to seamless objects
			if obj.parent != s_obj:
				obj.matrix_parent_inverse = s_obj.matrix_world.inverted()
				obj.parent = s_obj

			# Set clipping
			obj[SEAMLESS_CLIP] = self.clip

			# Update proxies
			self.sproxy_update(obj, s_prox, sp_group, scene, props)

		self.sproxy_end(context)
		wm.progress_end()
		return {'FINISHED'}

class SeamlessOperator_Compile(Operator, ObjectModeSeamless, SeamlessProxyManager):
	"""Compile seamless objects into a static form or single mesh."""
	bl_idname = "seamless.compile"
	bl_label = "Compile Seamless Objects"

	def compile_mesh_layers(self, meshes, props):
		m_rand_vc_a = props.compile_mesh_random_vcol_a
		m_rand_vc_a_name = props.compile_mesh_random_vcol_a_name
		m_rand_vc_b = props.compile_mesh_random_vcol_b
		m_rand_vc_b_name = props.compile_mesh_random_vcol_b_name
		m_rand_uv = props.compile_mesh_random_uv
		m_rand_uv_name = props.compile_mesh_random_uv_name
		m_loc_uv = props.compile_mesh_location_uv
		m_loc_uv_name = props.compile_mesh_location_uv_name
		m_loc_uv_name_2 = props.compile_mesh_location_uv_name_2
		m_loc_uv_ch = props.compile_mesh_location_uv_ch
		m_loc_uv_4m = props.compile_mesh_location_uv_4m
		m_obj_uv = props.compile_mesh_object_uv
		m_obj_uv_name = props.compile_mesh_object_uv_name
		m_obj_uv_name_2 = props.compile_mesh_object_uv_name_2
		m_obj_uv_rot = props.compile_mesh_object_uv_rot
		m_obj_uv_ch = props.compile_mesh_object_uv_ch
		m_obj_uv_4m = props.compile_mesh_object_uv_4m

		if not m_rand_vc_a + m_rand_vc_b + m_rand_uv + m_loc_uv + m_obj_uv:
			return

		for obj in meshes:
			if obj.data.users > 1:
				obj.data = obj.data.copy()

		seed()
		
		if m_rand_vc_a:
			for obj in meshes:
				vc = obj.data.vertex_colors
				try:
					vc_data = vc[m_rand_vc_a_name].data
				except:
					vc_data = vc.new(m_rand_vc_a_name).data
				if not vc_data:
					continue
				color = [random(), random(), random()]
				for loop in vc_data:
					loop.color[:] = color

		if m_rand_vc_b:
			for obj in meshes:
				vc = obj.data.vertex_colors
				try:
					vc_data = vc[m_rand_vc_b_name].data
				except:
					vc_data = vc.new(m_rand_vc_b_name).data
				if not vc_data:
					continue
				color = [random(), random(), random()]
				for loop in vc_data:
					loop.color[:] = color

		if m_rand_uv:
			for obj in meshes:
				uv = obj.data.uv_layers
				try:
					uv_data = uv[m_rand_uv_name].data
				except:
					obj.data.uv_textures.new(m_rand_uv_name)
					uv_data = uv[m_rand_uv_name].data
				if not uv_data:
					continue
				values = [random(), random()]
				for loop in uv_data:
					loop.uv[:] = values

		if m_loc_uv:
			for index, obj in enumerate(meshes):
				uv = obj.data.uv_layers
				try:
					uv_data = uv[m_loc_uv_name].data
				except:
					obj.data.uv_textures.new(m_loc_uv_name)
					uv_data = uv[m_loc_uv_name].data
				if not uv_data:
					continue
				values = [obj.location[0], obj.location[1]]
				for loop in uv_data:
					loop.uv[:] = values

				if m_loc_uv_ch != "4":
					continue

				try:
					uv_data = uv[m_loc_uv_name_2].data
				except:
					obj.data.uv_textures.new(m_loc_uv_name_2)
					uv_data = uv[m_loc_uv_name_2].data
				if not uv_data:
					continue

				values = [obj.location[2], random() if m_loc_uv_4m == "RANDOM" else index]
				for loop in uv_data:
					loop.uv[:] = values

		if m_obj_uv:
			for index, obj in enumerate(meshes):
				uv = obj.data.uv_layers
				try:
					uv_data = uv[m_obj_uv_name].data
				except:
					obj.data.uv_textures.new(m_obj_uv_name)
					uv_data = uv[m_obj_uv_name].data
				if not uv_data:
					continue
				
				scale = obj.scale
				verts = [Vector((v.co[0] * scale[0], v.co[1] * scale[1], v.co[2] * scale[2])) for v in obj.data.vertices]
				if m_obj_uv_rot:
					quat = obj.matrix_world.to_quaternion()
					verts = [quat * v for v in verts]

				loops = obj.data.loops
				for i, loop in enumerate(uv_data):
					loop.uv[:] = verts[loops[i].vertex_index][:2]

				if m_obj_uv_ch != "4":
					continue

				try:
					uv_data = uv[m_obj_uv_name_2].data
				except:
					obj.data.uv_textures.new(m_obj_uv_name_2)
					uv_data = uv[m_obj_uv_name_2].data
				if not uv_data:
					continue

				value = random() if m_obj_uv_4m == "RANDOM" else index
				for i, loop in enumerate(uv_data):
					loop.uv[:] = [verts[loops[i].vertex_index][2], value]

	def compile_mesh(self, context, props, objects, parent, name):
		m_convert = props.compile_mesh_convert
		window = context.window
		screen = context.screen
		area = context.area
		region = context.region
		scene = context.scene
		blend_data = context.blend_data
		if m_convert:
			selected_editable_bases = [scene.object_bases[obj.name] for obj in objects]
			override = {
				"active_object": objects[0],
				"object": objects[0],
				"selected_objects": objects,
				"window": window,
				"screen": screen,
				"area": area,
				"region": region,
				"scene": scene,
				"blend_data": blend_data,
				"selected_editable_bases": selected_editable_bases
			}
			old = objects[0].select
			objects[0].select = True # active object has to have select True or poll fails...
			# Meanwhile, selected objects for context override don't need select to be True? WTF?
			bpy.ops.object.convert(override, target="MESH", keep_original=False)
			objects[0].select = old

		meshes = [obj for obj in objects if obj.type == "MESH" and obj.dupli_type == "NONE"]
		if not meshes:
			return None

		self.compile_mesh_layers(meshes, props)

		def setup(obj):
			obj.parent = parent

		def get_data(name, context):
			meshes = bpy.data.meshes
			data = meshes.new(name)
			data.update()
			return data

		mesh_main = get_object(name, context, True, setup, get_data)
		if not mesh_main:
			return None

		meshes.append(mesh_main)
		selected_editable_bases = [scene.object_bases[obj.name] for obj in meshes]
		override = {
			"active_object": mesh_main,
			"object": mesh_main,
			"selected_objects": meshes,
			"window": window,
			"screen": screen,
			"area": area,
			"region": region,
			"scene": scene,
			"blend_data": blend_data,
			"selected_editable_bases": selected_editable_bases
		}
		bpy.ops.object.join(override)
		return mesh_main

	def execute(self, context):
		s_obj = get_seamless_objects(context)
		if not s_obj:
			return {'CANCELLED'}
		seamless_objects = s_obj.children
		if len(seamless_objects) < 1:
			return {'CANCELLED'}
		
		scene = context.scene
		props = scene.seamless
		self.sproxy_begin(context)

		sp_deletion = self._sp_deletion
		sp_unlink_groups = self._sp_unlink_groups
		sp_link_groups = self._sp_link_groups
		so_group = get_so_group()
		sp_group = get_sp_group()

		c_type = props.compile_type
		c_name = props.compile_name
		c_cleanup = props.compile_cleanup
		c_clear_rb = props.compile_clear_rb
		c_reinsert = props.compile_reinsert
		c_layers = props.compile_layers
		m_group = props.compile_mesh_group
		m_all = props.compile_mesh_all

		self.mesh_object = None
		self.group = None

		if c_type == "MESH":
			self.mesh_object = self.compile_mesh(context, props, seamless_objects, s_obj, c_name)
			if not self.mesh_object:
				self.report({'WARNING'}, "No seamless mesh objects to compile!")
				return {'CANCELLED'}
			self.mesh_object.parent = None
			if True in c_layers:
				self.mesh_object.layers[:] = c_layers

		seamless_objects = s_obj.children
		if c_type == "GROUP" or m_group:
			if c_type == "MESH" and not m_all:
				objects = [self.mesh_object]
			else:
				objects = list(seamless_objects)
				if self.mesh_object:
					objects.append(self.mesh_object)

			if len(objects) < 1:
				self.report({'WARNING'}, "No seamless objects to compile!")
				return {'CANCELLED'}

			group = get_group(c_name, True)
			group_objects = group.objects
			self.group = group
			
			if not c_cleanup:
				for obj in objects:
					for g in obj.users_group:
						if g.name.startswith("~"):
							sp_unlink_groups[g].add(obj)

			group_set = sp_link_groups[group]
			sp_rb_remove = self._sp_rb_remove
			assign_layers = True in c_layers
			for obj in objects:
				group_set.add(obj)
				obj.parent = None
				if c_clear_rb:
					if obj.rigid_body:
						sp_rb_remove.add(obj)
				if assign_layers:
					obj.layers[:] = c_layers

		if c_cleanup:
			for proxy in sp_group.objects:
				sp_deletion.add(proxy)

			for obj in seamless_objects:
				obj.parent = None
		else:
			for proxy in sp_group.objects:
				try:
					target = proxy.constraints[0].target
				except:
					sp_deletion.add(proxy)
					continue
				if target:
					if target.parent != s_obj:
						sp_deletion.add(proxy)
				else:
					sp_deletion.add(proxy)

		if c_reinsert and not c_cleanup:
			s_prox = get_seamless_proxies(context, True)
			ri_object = None
			if self.group:
				def setup(obj):
					obj.dupli_type = "GROUP"
					obj.dupli_group = self.group

				ri_object = get_object(c_name + "_group_inst", context, True, setup)
			elif self.mesh_object:
				ri_object = self.mesh_object
				for index, value in enumerate(s_obj.layers):
					if value: ri_object.layers[index] = True

			if ri_object:
				scene.update()
				sp_link_groups[so_group].add(ri_object)
				ri_object.parent = s_obj
				ri_object[SEAMLESS_LEVEL] = props.level
				ri_object[SEAMLESS_CLIP] = False
				self.sproxy_update(ri_object, s_prox, sp_group, scene, props)

		self.sproxy_end(context)

		if self.group:
			for obj in self.group.objects:
				obj.location = obj.location

		if c_cleanup:
			groups = bpy.data.groups
			if so_group:
				groups.remove(so_group)
			if sp_group:
				groups.remove(sp_group)

			spgs = []
			for group in groups:
				if group.name.startswith(SEAMLESS_PROXY_PREFIX):
					spgs.append(group)

			for group in spgs:
				groups.remove(group)

			objects = bpy.data.objects
			seamless_system_objects = [obj for obj in objects if obj.name.startswith("~seamless")]
			delete_objects(seamless_system_objects)

		return {'FINISHED'}

def _remove_all(self, context):
	self.sproxy_begin(context)
		
	sp_deletion = self._sp_deletion
	sp_unlink_groups = self._sp_unlink_groups

	so_group = get_so_group()
	sp_group = get_sp_group()

	if sp_group:
		sp_objects = sp_group.objects
		for obj in sp_objects:
			sp_deletion.add(obj)

	groups = bpy.data.groups
	if so_group:
		groups.remove(so_group)
	if sp_group:
		groups.remove(sp_group)

	spgs = []
	for group in groups:
		if group.name.startswith(SEAMLESS_PROXY_PREFIX):
			spgs.append(group)

	for group in spgs:
		groups.remove(group)
		
	s_obj = get_seamless_objects(context)
	if s_obj:
		children = list(s_obj.children)
		for obj in children:
			mat = obj.matrix_world
			obj.parent = None
			obj.matrix_world = mat

	self.sproxy_end(context)

class SeamlessOperator_RemoveAll(Operator, ObjectModeSeamless, SeamlessProxyManager):
	"""Remove all objects from seamless area."""
	bl_idname = "seamless.remove_all"
	bl_label = "Remove All Seamless"

	def execute(self, context):
		_remove_all(self, context)
		return {'FINISHED'}

class SeamlessOperator_Cleanup(Operator, ObjectModeSeamless, SeamlessProxyManager):
	"""Remove all objects from seamless area and remove seamless area."""
	bl_idname = "seamless.cleanup"
	bl_label = "Cleanup Seamless"

	def execute(self, context):
		_remove_all(self, context)
		so_group = get_so_group()
		sp_group = get_sp_group()
		groups = bpy.data.groups
		if so_group:
			groups.remove(so_group)
		if sp_group:
			groups.remove(sp_group)

		spgs = []
		for group in groups:
			if group.name.startswith(SEAMLESS_PROXY_PREFIX):
				spgs.append(group)

		for group in spgs:
			groups.remove(group)

		objects = bpy.data.objects
		seamless_system_objects = [obj for obj in objects if obj.name.startswith("~seamless")]
		delete_objects(seamless_system_objects)
		return {'FINISHED'}

class SeamlessOperator_SetProxyVisibility(Operator, ObjectModeSeamless):
	"""Set proxy visibility."""
	bl_idname = "seamless.set_proxy_vis"
	bl_label = "Set Seamless Proxy Visibility"

	selected = BoolProperty(
		name="Selected",
		description="Only set clip state of selected seamless objects.",
		default=False
		)

	def execute(self, context):
		p_obj = get_seamless_proxies(context)
		proxies = p_obj.children
		if self.selected:
			_selprox = []
			for proxy in proxies:
				try:
					target = proxy.constraints[0].target
				except:
					continue
				if target.select:
					_selprox.append(proxy)
			proxies = _selprox
		if len(proxies) < 1:
			return {'CANCELLED'}
		
		props = context.scene.seamless
		for proxy in proxies:
			proxy.hide = props.vis_hide
			proxy.hide_select = props.vis_hide_select
			proxy.hide_render = props.vis_hide_render
			proxy.draw_type = props.vis_draw_type
		return {'FINISHED'}



class SeamlessOperator_CreateCamera(Operator, ObjectMode):
	"""Create a camera linked to the seamless area."""
	bl_idname = "seamless.create_camera"
	bl_label = "Create Seamless Camera"

	@classmethod
	def poll(cls, context):
		return not bool(get_seamless_camera(context)) and ObjectMode.poll(context)

	def execute(self, context):
		sc = get_seamless_camera(context, True)
		if not sc:
			return {'CANCELLED'}

		props = context.scene.seamless
		update_camera(props, context)
		context.scene.camera = sc

		return {'FINISHED'}

class SeamlessOperator_DeleteCamera(Operator, ObjectMode):
	"""Delete the camera linked to the seamless area."""
	bl_idname = "seamless.delete_camera"
	bl_label = "Delete Seamless Camera"

	@classmethod
	def poll(cls, context):
		return bool(get_seamless_camera(context)) and ObjectMode.poll(context)

	def execute(self, context):
		sc = get_seamless_camera(context)
		if not sc:
			return {'CANCELLED'}

		delete_objects(sc)

		return {'FINISHED'}

class SeamlessOperator_FlipCamera(Operator, ObjectMode):
	"""Flip the camera linked to the seamless area."""
	bl_idname = "seamless.flip_camera"
	bl_label = "Flip Seamless Camera"

	@classmethod
	def poll(cls, context):
		return bool(get_seamless_camera(context)) and ObjectMode.poll(context)

	def execute(self, context):
		sc = get_seamless_camera(context)
		if not sc:
			return {'CANCELLED'}

		if sc.location[2] >= 0:
			sc.location[2] = -sc.location[2]
			sc.rotation_euler[1] = 3.1415927410125732
		else:
			sc.location[2] = -sc.location[2]
			sc.rotation_euler[1] = 0.0

		return {'FINISHED'}

class SeamlessOperator_ResetCamera(Operator, ObjectMode):
	"""Reset the camera linked to the seamless area."""
	bl_idname = "seamless.reset_camera"
	bl_label = "Reset Seamless Camera"

	@classmethod
	def poll(cls, context):
		return bool(get_seamless_camera(context)) and ObjectMode.poll(context)

	def execute(self, context):
		sc = get_seamless_camera(context)
		if not sc:
			return {'CANCELLED'}

		sc.location[0] = 0.0
		sc.location[1] = 0.0
		sc.location[2] = 32.0
		sc.rotation_euler[0] = 0.0
		sc.rotation_euler[1] = 0.0
		sc.rotation_euler[2] = 0.0
		sc.data.type = "ORTHO"

		props = context.scene.seamless
		update_camera(props, context)

		return {'FINISHED'}

class SeamlessOperator_ViewDocs(Operator):
	"""View seamless tools documentation."""
	bl_idname = "seamless.view_docs"
	bl_label = "View Seamless Tools Documentation"
	bl_options = {'REGISTER'}

	def execute(self, context):
		from os import path
		import webbrowser as wb
		wb.open("file:///" + path.join(path.dirname(__file__), "readme.html"))
		return {'FINISHED'}

class SeamlessOperator_LoadNodeGroups(Operator):
	"""Load seamless node groups."""
	bl_idname = "seamless.load_node_groups"
	bl_label = "Load Seamless Node Groups"
	bl_options = {'REGISTER','UNDO'}

	def execute(self, context):
		unpack_node_groups()
		update_node_groups(context.scene.seamless, context)
		return {'FINISHED'}

class SeamlessOperator_RefreshNodeGroups(Operator):
	"""Refresh seamless node groups."""
	bl_idname = "seamless.refresh_node_groups"
	bl_label = "Refresh Seamless Node Groups"
	bl_options = {'REGISTER','UNDO'}

	def execute(self, context):
		update_node_groups(context.scene.seamless, context)
		return {'FINISHED'}

class SeamlessOperator_RefreshParticleSystem(Operator):
	"""Refresh particle system because driven seed value does not update particle locations and locations are not updated when adding to seamless area."""
	bl_idname = "seamless.refresh_particle_system"
	bl_label = "Refresh Particle System"
	bl_options = {'REGISTER', 'UNDO', 'INTERNAL'}

	count = IntProperty(default=-1)
	distribution = StringProperty(default="")

	def execute(self, context):
		psys = context.particle_system
		if not psys:
			return
		settings = psys.settings
		if not settings:
			return
		settings.distribution = settings.distribution if not self.distribution else self.distribution
		settings.count = settings.count if self.count < 0 else self.count

		return {'FINISHED'}

class SeamlessOperator_RefreshProxyParticleSystem(Operator):
	"""Refresh particle system because driven seed value does not update particle locations and locations are sometimes not updated when adding to seamless area."""
	bl_idname = "seamless.refresh_proxy_particle_system"
	bl_label = "Refresh Proxy Particle System"
	bl_options = {'REGISTER', 'UNDO', 'INTERNAL'}

	def execute(self, context):
		def close(f1, f2):
			return abs(f1-f2) <= abs(f1) * 1e-5

		psys = context.particle_system
		if not psys:
			return
		settings = psys.settings
		if not settings:
			return
		settings.distribution = settings.distribution
		settings.count = settings.count
		num = settings.count
		dist = settings.distribution

		# Check for duplicates
		ob = context.object
		index = ob.particle_systems.active_index
		sprox = [g.objects for g in ob.users_group if g.name.startswith(SEAMLESS_PROXY_PREFIX)]
		if sprox:
			for proxy in sprox[0]:
				try: psys = proxy.particle_systems[index]
				except: continue
				window = context.window
				screen = context.screen
				area = context.area
				region = context.region
				scene = context.scene
				blend_data = context.blend_data
				override = {
					"active_object": ob,
					"object": ob,
					"particle_system": psys,
					"window": window,
					"screen": screen,
					"area": area,
					"region": region,
					"scene": scene,
					"blend_data": blend_data,
				}
				bpy.ops.seamless.refresh_particle_system(override, count=num, distribution=dist)

		return {'FINISHED'}

# Scene Properties
ei_res_mode = (
	("MIN","Min","Use minimum resolution."),
	("MAX","Max","Use maximum resolution.")
)

ei_draw_type = (
	("TEXTURED","Textured","Textured viewport shading.", "POTATO", 0),
	("SOLID","Solid","Solid viewport shading.", "SOLID", 1),
	("WIRE","Wire","Wire viewport drawing.", "WIRE", 2),
	("BOUNDS","Bounds","Bounding box viewport drawing.", "BBOX", 3),
)

ei_compile_type = (
	("GROUP","Group","Compile seamless objects to a group.", "GROUP", 0),
	("MESH","Mesh","Compile compatible seamless objects to a single mesh.", "OUTLINER_OB_MESH", 1),
)

ei_uv_type = (
	("2","2 Channel","Use a single UV layer (Z is excluded)."),
	("4","4 Channel","Use two UV layers.")
)

ei_uv_fourth = (
	("RANDOM","Random","Random value per object ranging from 0.0 to 1.0."),
	("UNIQUE","Unique","Unique value per object starting at 0 incrementing by 1 each time.")
)

ei_psys_mode = (
	("NONE","None","No action is taken. No drivers are created for the seed value.", "DOT", 0),
	("REMOVE","Remove","Particle systems are removed from seamless proxies.", "CANCEL", 1),
	("LINKED","Linked","Random element order is turned off. Seeds are connected with drivers.", "PARTICLES", 2),
	("DUPLICATE","Duplicate","Particle settings are duplicated for each seamless proxy. Seeds are connected with drivers. NOTE: Use this if you want to keep random element order. Other caveats apply. See documentation.", "MOD_PARTICLES", 3),
)

uperf = None
class SeamlessSceneProps(PropertyGroup):
	@classmethod
	def register(cls):
		bpy.types.Scene.seamless = PointerProperty(
			name="Seamless Scene Properties",
			description="Per scene seamless area and tool settings.",
			type=cls,
			)
	
	@classmethod
	def unregister(cls):
		try:
			del bpy.types.Scene.seamless
		except:
			pass

	tile_x = IntProperty(
		name="Tile X",
		description="Size of seamless X area.",
		default=8,
		min=1,
		update=update_tile_x
		)

	tile_y = IntProperty(
		name="Tile Y",
		description="Size of seamless Y area.",
		default=8,
		min=1,
		update=update_tile_y
		)

	use_tile_x = BoolProperty(
		name="Use X Axis",
		description="Tile proxies on X axis.",
		default=True
		)

	use_tile_y = BoolProperty(
		name="Use Y Axis",
		description="Tile proxies on Y axis.",
		default=True
		)

	use_margin = BoolProperty(
		name="Use Margin",
		description="Enable rigid body margin.",
		default=False,
		update=update_margin
		)

	use_floor = BoolProperty(
		name="Use Floor",
		description="Enable rigid body floor.",
		default=False,
		update=update_floor
		)

	margin = FloatProperty(
		name="Margin",
		description="Rigid body margin around seamless area.",
		default=1.0,
		min=0.0,
		update=update_margin
		)

	floor = FloatProperty(
		name="Floor",
		description="Rigid body floor height for seamless area.",
		default=0,
		update=update_floor
		)

	res_mode = EnumProperty(
		name="Resolution Mode",
		description="Set either minimum or maximum render resolution",
		items=ei_res_mode,
		default='MIN',
		update=update_camera
		)

	min_res = IntProperty(
		name="Minimum Resolution",
		description="Minimum render resolution.",
		subtype="PIXEL",
		default=1024,
		min=1,
		update=update_camera
		)

	max_res = IntProperty(
		name="Maximum Resolution",
		description="Maximum render resolution.",
		subtype="PIXEL",
		default=1024,
		min=1,
		update=update_camera
		)

	show_area = BoolProperty(
		name="Show Area",
		description="Toggle visibility of seamless area.",
		default=True
		)

	show_margin = BoolProperty(
		name="Show Margin",
		description="Toggle visibility of rigid body margin.",
		default=True
		)

	show_floor = BoolProperty(
		name="Show Floor",
		description="Toggle visibility of rigid body floor.",
		default=True
		)

	show_proxies = BoolProperty(
		name="Show Proxies",
		description="Toggle visibility of proxy locations.",
		default=True
		)

	show_compile = BoolProperty(
		name="Compile Seamless Settings",
		description="Toggle visibility of compile seamless settings.",
		default=False
		)

	optimize = BoolProperty(
		name="Optimize Position",
		description="Optimize seamless object position by keeping it inside the seamless area.",
		default=True
		)

	clip = BoolProperty(
		name="Enable Clipping",
		description="Clip seamless proxies for new seamless objects that are not inside the seamless area and margin.",
		default=True
		)

	level = IntProperty(
		name="Proxy Level",
		description="Number of proxy layers to create.",
		default=1,
		min=1
		)

	psys = BoolProperty(
		name="Use Particle Systems",
		description="Turn this off and all particle systems are removed from proxies, otherwise the seamless mode specified in the particle system properties page is used.",
		default=True
		)

	default_hide = BoolProperty(
		name="Hide Proxies",
		description="New proxies are hidden.",
		default=False
		)

	default_hide_select = BoolProperty(
		name="Hide Proxy Select",
		description="New proxies are hidden from selection.",
		default=True
		)

	default_hide_render = BoolProperty(
		name="Hide Proxy Render",
		description="New proxies are hidden from render.",
		default=False
		)

	default_draw_type = EnumProperty(
		name="Proxy Draw Type",
		description="Draw type of new proxies",
		items=ei_draw_type,
		default='BOUNDS'
		)

	vis_hide = BoolProperty(
		name="Hide Proxies",
		description="Hide proxies.",
		default=False
		)

	vis_hide_select = BoolProperty(
		name="Hide Proxy Select",
		description="Hide proxies from selection.",
		default=True
		)

	vis_hide_render = BoolProperty(
		name="Hide Proxy Render",
		description="Hide proxies from render.",
		default=False
		)

	vis_draw_type = EnumProperty(
		name="Proxy Draw Type",
		description="Draw type of proxies",
		items=ei_draw_type,
		default='BOUNDS'
		)

	compile_type = EnumProperty(
		name="Compile Type",
		description="Seamless compile type",
		items=ei_compile_type,
		default='GROUP'
		)

	compile_name = StringProperty(
		name="Compile Name",
		description="Name of group and/or mesh to be compiled.",
		default="name_of_result"
		)

	compile_cleanup = BoolProperty(
		name="Clear Seamless",
		description="Clear seamless area and all dependencies.",
		default=False
		)

	compile_reinsert = BoolProperty(
		name="Reinsert Result",
		description="After compiling reinsert the compiled result into the seamless area.",
		default=True
		)

	compile_clear_rb = BoolProperty(
		name="Clear Rigid Body",
		description="Clear rigid body settings from compiled objects.",
		default=True
		)

	compile_layers = BoolVectorProperty(
		name="Compile Layers",
		description="Layer(s) to place compiled result in... Wow! Still no named layers? What a headache!",
		size=20,
		default=[False]*20,
		subtype="LAYER"
		)

	compile_mesh_group = BoolProperty(
		name="Use Group",
		description="Use group for resulting mesh and optionally other objects.",
		default=False
		)

	compile_mesh_all = BoolProperty(
		name="All Objects",
		description="Include all non-mesh objects in result.",
		default=False
		)

	compile_mesh_convert = BoolProperty(
		name="Convert Non-Mesh",
		description="Include mesh convertible non-mesh objects (curves, text, surface, etc.).",
		default=True
		)

	compile_mesh_random_vcol_a = BoolProperty(
		name="Random VCOL A",
		description="Add random vertex colors per object.",
		default=False
		)

	compile_mesh_random_vcol_a_name = StringProperty(
		name="Random VCOL A Name",
		description="Name of random vertex color layer.",
		default="vc_rand_a"
		)

	compile_mesh_random_vcol_b = BoolProperty(
		name="Random VCOL B",
		description="Add random vertex colors per object.",
		default=False
		)

	compile_mesh_random_vcol_b_name = StringProperty(
		name="Random VCOL B Name",
		description="Name of random vertex color layer.",
		default="vc_rand_b"
		)

	compile_mesh_random_uv = BoolProperty(
		name="Random UV",
		description="Add random UVs per object.",
		default=False
		)

	compile_mesh_random_uv_name = StringProperty(
		name="Random UV Name",
		description="Name of random UV layer.",
		default="uv_rand"
		)

	compile_mesh_location_uv = BoolProperty(
		name="Location UV",
		description="Add location UVs per object.",
		default=False
		)

	compile_mesh_location_uv_name = StringProperty(
		name="Location UV Name",
		description="Name of location UV layer.",
		default="uv_location"
		)

	compile_mesh_location_uv_name_2 = StringProperty(
		name="Location UV Name 2",
		description="Name of second location UV layer.",
		default="uv_location_2"
		)

	compile_mesh_object_uv = BoolProperty(
		name="Object UV",
		description="Add object space UVs per object.",
		default=False
		)

	compile_mesh_object_uv_name = StringProperty(
		name="Object UV Name",
		description="Name of object space UV layer.",
		default="uv_object"
		)

	compile_mesh_object_uv_name_2 = StringProperty(
		name="Object UV Name 2",
		description="Name of second object space UV layer.",
		default="uv_object_2"
		)

	compile_mesh_object_uv_rot = BoolProperty(
		name="Object UV Apply Rotation",
		description="Apply rotation for object space UVs. Recommended for 2 channel mode.",
		default=False
		)

	compile_mesh_location_uv_ch = EnumProperty(
		name="Location UV Channels",
		description="Channel count for location UVs",
		items=ei_uv_type,
		default="2"
		)

	compile_mesh_location_uv_4m = EnumProperty(
		name="Location UV Fourth",
		description="What to do with the fourth UV channel",
		items=ei_uv_fourth,
		default="RANDOM"
		)

	compile_mesh_object_uv_ch = EnumProperty(
		name="Object UV Channels",
		description="Channel count for object space UVs",
		items=ei_uv_type,
		default="2"
		)

	compile_mesh_object_uv_4m = EnumProperty(
		name="Object UV Fourth",
		description="What to do with the fourth UV channel",
		items=ei_uv_fourth,
		default="RANDOM"
		)

class SeamlessParticleSysProps(PropertyGroup):
	@classmethod
	def register(cls):
		bpy.types.ParticleSettings.seamless = PointerProperty(
			name="Seamless Particle System Properties",
			description="Properties that define handling of particle systems on objects added to the seamless area.",
			type=cls,
			)
	
	@classmethod
	def unregister(cls):
		try:
			del bpy.types.ParticleSettings.seamless
		except:
			pass

	mode = EnumProperty(
		name="Seamless Particle System Mode",
		description="Action to take for particle system when added to the seamless area. WARNING: This must be set before particle system is added to seamless area",
		items=ei_psys_mode,
		default="LINKED",
		)

	mode_last = EnumProperty(
		items=ei_psys_mode,
		default="LINKED",
		)

	is_proxy = BoolProperty(default=False)

# Addon Properties
class SeamlessAddonPreferences(AddonPreferences):
	bl_idname = __package__

	col_seamless_area = FloatVectorProperty(
		name="Seamless Area",
		description="Color of seamless area.",
		subtype="COLOR",
		size=3,
		default=[1.0, 1.0, 0.0],
		min=0.0,
		max=1.0
		)

	col_seamless_margin = FloatVectorProperty(
		name="Seamless Margin",
		description="Color of seamless area's margin.",
		subtype="COLOR",
		size=3,
		default=[0.0, 0.8, 1.0],
		min=0.0,
		max=1.0
		)

	col_seamless_floor = FloatVectorProperty(
		name="Seamless Floor",
		description="Color of seamless area's floor.",
		subtype="COLOR",
		size=3,
		default=[1.0, 0.2, 0.2],
		min=0.0,
		max=1.0
		)

	col_seamless_proxies = FloatVectorProperty(
		name="Seamless Proxies",
		description="Color of seamless proxy locations.",
		subtype="COLOR",
		size=3,
		default=[1.0, 0.0, 1.0],
		min=0.0,
		max=1.0
		)

	show_help_panel = BoolProperty(
		name="Show Help Panel",
		description="Toggle display of help panel containing a link to the documentation.",
		default=True
		)

	def draw(self, context):
		l = self.layout
		r = l.split(percentage=0.5)
		c = r.column()
		b = c.box()
		cc = b.column(True)
		cc.row(True).prop(self, "col_seamless_area")
		cc.row(True).prop(self, "col_seamless_margin")
		cc.row(True).prop(self, "col_seamless_floor")
		cc.row(True).prop(self, "col_seamless_proxies")
		c = r.column()
		c.scale_y = 1.5
		c.operator(SeamlessOperator_ViewDocs.bl_idname, "View Documentation", icon="QUESTION")
		b = c.box()
		cc = b.column(True)
		cc.row(True).prop(self, "show_help_panel")

# Panels
def layout_opop(o, n, l, p, text="", icon="NONE"):
	row = l.row(align=True)
	box = row.box()
	split = box.row(align=True)
	show = getattr(p, n, False)
	if show:
		split.prop(p, n, text="", icon="DISCLOSURE_TRI_DOWN")
	else:
		split.prop(p, n, text="", icon="DISCLOSURE_TRI_RIGHT")
	split.operator(o.bl_idname, text=text, icon=icon)
	return show, box

class SeamlessAreaPanel(Panel):
	bl_label = "Area"
	bl_space_type = "VIEW_3D"
	bl_region_type = "TOOLS"
	bl_context = "objectmode"
	bl_category = "Physics"

	def draw(self, context):
		l = self.layout
		p = context.scene.seamless
		r = l.row(True)
		r.prop(p, "tile_x", "X")
		r.prop(p, "tile_y", "Y")
		rr = r.row(True)
		rr.alignment = "LEFT"
		rr.prop(p, "use_tile_x", "X", toggle=True)
		rr.prop(p, "use_tile_y", "Y", toggle=True)
		c = l.column(True)
		r = c.row(True)
		r.row(True).prop(p, "use_margin", "Margin", toggle=True, icon="FILE_TICK" if p.use_margin else "BLANK1")
		r = r.row(True)
		r.enabled = p.use_margin
		r.prop(p, "margin", "")
		r = c.row(True)
		r.row(True).prop(p, "use_floor", "Floor", toggle=True, icon="FILE_TICK" if p.use_floor else "BLANK1")
		r = r.row(True)
		r.enabled = p.use_floor
		r.prop(p, "floor", "")

class SeamlessToolsPanel(Panel):
	bl_label = "Tools"
	bl_space_type = "VIEW_3D"
	bl_region_type = "TOOLS"
	bl_context = "objectmode"
	bl_category = "Physics"

	def draw(self, context):
		l = self.layout
		p = context.scene.seamless
		c = l.column(True)
		r = c.row(True)
		r.operator(SeamlessOperator_Add.bl_idname, "Add", icon="ZOOMIN")
		r.operator(SeamlessOperator_Remove.bl_idname, "Remove", icon="ZOOMOUT")
		r = c.row(True)
		r.prop(p, "level", "Layers")
		r.prop(p, "psys", "", toggle=True, icon="PARTICLES")
		r.prop(p, "clip", "", toggle=True, icon="STICKY_UVS_LOC" if p.clip else "STICKY_UVS_DISABLE")
		r.prop(p, "optimize", "", toggle=True, icon="AXIS_TOP")
		r = c.row(True)
		if p.default_hide:
			r.prop(p, "default_hide", "", icon="RESTRICT_VIEW_ON")
		else:
			r.prop(p, "default_hide", "", icon="RESTRICT_VIEW_OFF")
		if p.default_hide_select:
			r.prop(p, "default_hide_select", "", icon="RESTRICT_SELECT_ON")
		else:
			r.prop(p, "default_hide_select", "", icon="RESTRICT_SELECT_OFF")
		if p.default_hide_render:
			r.prop(p, "default_hide_render", "", icon="RESTRICT_RENDER_ON")
		else:
			r.prop(p, "default_hide_render", "", icon="RESTRICT_RENDER_OFF")
		r.prop(p, "default_draw_type", "")
		r = c.row(True)
		r.alignment = "EXPAND"
		r.operator(SeamlessOperator_Refresh.bl_idname, "Refresh", icon="FILE_REFRESH").selected = False
		r.operator(SeamlessOperator_Refresh.bl_idname, "", icon="RESTRICT_SELECT_OFF").selected = True
		c = l.column(True)
		r = c.row(True)
		r.operator(SeamlessOperator_Select.bl_idname, "Select", icon="RESTRICT_SELECT_OFF")
		r.operator(SeamlessOperator_Deselect.bl_idname, "Deselect", icon="RESTRICT_SELECT_ON")
		r = c.row(True)
		r.operator(SeamlessOperator_InvertSelection.bl_idname, "Invert Selection", icon="AUTOMERGE_ON")
		r = c.row(True)
		r.operator(SeamlessOperator_SelectSeamlessArea.bl_idname, "Select Area", icon="BORDER_RECT")
		r = c.row(True)
		r.operator(SeamlessOperator_CursorToSeamlessArea.bl_idname, "Cursor to Area", icon="CURSOR")
		c = l.column(True)
		r = c.row(True)
		r.operator(SeamlessOperator_ApplyVisualTransform.bl_idname, "Apply Visual Tx", icon="EXPORT").selected = False
		r.operator(SeamlessOperator_ApplyVisualTransform.bl_idname, "", icon="RESTRICT_SELECT_OFF").selected = True
		r = c.row(True)
		r.operator(SeamlessOperator_ActiveToPassive.bl_idname, "Active To Passive", icon="PHYSICS").selected = False
		r.operator(SeamlessOperator_ActiveToPassive.bl_idname, "", icon="RESTRICT_SELECT_OFF").selected = True
		r = c.row(True)
		ops = r.operator(SeamlessOperator_Clip.bl_idname, "Enable Clipping", icon="STICKY_UVS_LOC")
		ops.selected = False
		ops.clip = True
		ops = r.operator(SeamlessOperator_Clip.bl_idname, "", icon="RESTRICT_SELECT_OFF")
		ops.selected = True
		ops.clip = True
		r = c.row(True)
		ops = r.operator(SeamlessOperator_Clip.bl_idname, "Disable Clipping", icon="STICKY_UVS_DISABLE")
		ops.selected = False
		ops.clip = False
		ops = r.operator(SeamlessOperator_Clip.bl_idname, "", icon="RESTRICT_SELECT_OFF")
		ops.selected = True
		ops.clip = False
		c = l.column(True)
		r = c.row(True)
		if p.vis_hide:
			r.prop(p, "vis_hide", "", icon="RESTRICT_VIEW_ON")
		else:
			r.prop(p, "vis_hide", "", icon="RESTRICT_VIEW_OFF")
		if p.vis_hide_select:
			r.prop(p, "vis_hide_select", "", icon="RESTRICT_SELECT_ON")
		else:
			r.prop(p, "vis_hide_select", "", icon="RESTRICT_SELECT_OFF")
		if p.vis_hide_render:
			r.prop(p, "vis_hide_render", "", icon="RESTRICT_RENDER_ON")
		else:
			r.prop(p, "vis_hide_render", "", icon="RESTRICT_RENDER_OFF")
		r.prop(p, "vis_draw_type", "")
		r = c.row(True)
		r.operator(SeamlessOperator_SetProxyVisibility.bl_idname, "All", icon="GROUP").selected = False
		r.operator(SeamlessOperator_SetProxyVisibility.bl_idname, "Selected", icon="RESTRICT_SELECT_OFF").selected = True
		show, b = layout_opop(SeamlessOperator_Compile, "show_compile", l, p, "Compile Mesh" if p.compile_type == "MESH" else "Compile Group", "RADIO")
		if show:
			c = b.column(True)
			c.prop(p, "compile_type", "")
			c.prop(p, "compile_name", "")
			c.separator()
			c.prop(p, "compile_layers", "")
			c.separator()
			c.prop(p, "compile_cleanup")
			c.prop(p, "compile_clear_rb")
			r = c.row(True)
			r.enabled = not p.compile_cleanup
			r.prop(p, "compile_reinsert")
			if p.compile_type == "MESH":
				bb = b.box()
				cc = bb.column(True)
				cc.prop(p, "compile_mesh_group")
				r = cc.row(True)
				r.enabled = p.compile_mesh_group
				r.label("", icon="BLANK1")
				r.prop(p, "compile_mesh_all")
				cc.prop(p, "compile_mesh_convert")
				cc.label("Vertex Colors:")
				r = cc.row(True)
				r.label("", icon="BLANK1")
				r.prop(p, "compile_mesh_random_vcol_a", "Random A")
				if p.compile_mesh_random_vcol_a:
					r = cc.row(True)
					r.label("", icon="BLANK1")
					r.label("", icon="BLANK1")
					r.prop(p, "compile_mesh_random_vcol_a_name", "")
				r = cc.row(True)
				r.label("", icon="BLANK1")
				r.prop(p, "compile_mesh_random_vcol_b", "Random B")
				if p.compile_mesh_random_vcol_b:
					r = cc.row(True)
					r.label("", icon="BLANK1")
					r.label("", icon="BLANK1")
					r.prop(p, "compile_mesh_random_vcol_b_name", "")
				cc.label("UVs:")
				r = cc.row(True)
				r.label("", icon="BLANK1")
				r.prop(p, "compile_mesh_random_uv", "Random")
				if p.compile_mesh_random_uv:
					r = cc.row(True)
					r.label("", icon="BLANK1")
					r.label("", icon="BLANK1")
					r.prop(p, "compile_mesh_random_uv_name", "")
				r = cc.row(True)
				r.label("", icon="BLANK1")
				r.prop(p, "compile_mesh_location_uv", "Location")
				if p.compile_mesh_location_uv:
					r = cc.row(True)
					r.label("", icon="BLANK1")
					r.label("", icon="BLANK1")
					r.prop(p, "compile_mesh_location_uv_ch", "")
					if p.compile_mesh_location_uv_ch == "4":
						r = cc.row(True)
						r.label("", icon="BLANK1")
						r.label("", icon="BLANK1")
						r.prop(p, "compile_mesh_location_uv_4m", "")
					r = cc.row(True)
					r.label("", icon="BLANK1")
					r.label("", icon="BLANK1")
					r.prop(p, "compile_mesh_location_uv_name", "")
					if p.compile_mesh_location_uv_ch == "4":
						r = cc.row(True)
						r.label("", icon="BLANK1")
						r.label("", icon="BLANK1")
						r.prop(p, "compile_mesh_location_uv_name_2", "")
				r = cc.row(True)
				r.label("", icon="BLANK1")
				r.prop(p, "compile_mesh_object_uv", "Object Space")
				if p.compile_mesh_object_uv:
					r = cc.row(True)
					r.label("", icon="BLANK1")
					r.label("", icon="BLANK1")
					r.prop(p, "compile_mesh_object_uv_rot", "Rotate", toggle=True)
					r = cc.row(True)
					r.label("", icon="BLANK1")
					r.label("", icon="BLANK1")
					r.prop(p, "compile_mesh_object_uv_ch", "")
					if p.compile_mesh_object_uv_ch == "4":
						r = cc.row(True)
						r.label("", icon="BLANK1")
						r.label("", icon="BLANK1")
						r.prop(p, "compile_mesh_object_uv_4m", "")
					r = cc.row(True)
					r.label("", icon="BLANK1")
					r.label("", icon="BLANK1")
					r.prop(p, "compile_mesh_object_uv_name", "")
					if p.compile_mesh_object_uv_ch == "4":
						r = cc.row(True)
						r.label("", icon="BLANK1")
						r.label("", icon="BLANK1")
						r.prop(p, "compile_mesh_object_uv_name_2", "")

		r = l.row()
		r = r.box().row(True)
		r.operator(SeamlessOperator_RemoveAll.bl_idname, "Remove All", icon="X")
		r.operator(SeamlessOperator_Cleanup.bl_idname, "", icon="ERROR")

class SeamlessDisplayPanel(Panel):
	bl_label = "Display"
	bl_space_type = "VIEW_3D"
	bl_region_type = "TOOLS"
	bl_context = "objectmode"
	bl_category = "Physics"
	bl_options = {'DEFAULT_CLOSED'}

	def draw(self, context):
		l = self.layout
		p = context.scene.seamless
		c = l.column(True)
		r = c.row(True)
		r.prop(p, "show_area", "Area")
		r.prop(p, "show_proxies", "Proxies")
		r = c.row(True)
		r.enabled = p.show_area
		r.prop(p, "show_margin", "Margin")
		r.prop(p, "show_floor", "Floor")
		
class SeamlessCameraPanel(Panel):
	bl_label = "Camera"
	bl_space_type = "VIEW_3D"
	bl_region_type = "TOOLS"
	bl_context = "objectmode"
	bl_category = "Physics"

	def draw(self, context):
		l = self.layout
		p = context.scene.seamless
		nocam = SeamlessOperator_CreateCamera.poll(context)
		c = l.column(True)
		if nocam:
			c.operator(SeamlessOperator_CreateCamera.bl_idname, "Create Camera", icon="OUTLINER_OB_CAMERA")
		else:
			c.operator(SeamlessOperator_DeleteCamera.bl_idname, "Delete Camera", icon="X")
		r = c.row(True)
		r.operator(SeamlessOperator_FlipCamera.bl_idname, "Flip", icon="LAYER_USED")
		r.operator(SeamlessOperator_ResetCamera.bl_idname, "Reset", icon="LAYER_USED")
		c = l.column(True)
		if nocam:
			c.enabled = False
		c.label("Resolution:")
		s = c.row().split(0.4, True)
		s.prop(p, "res_mode", "")
		if p.res_mode == "MIN":
			s.prop(p, "min_res", "")
		else:
			s.prop(p, "max_res", "")

class SeamlessInfoPanel(Panel):
	bl_label = "Help"
	bl_space_type = "VIEW_3D"
	bl_region_type = "TOOLS"
	bl_context = "objectmode"
	bl_category = "Physics"
	bl_options = {'DEFAULT_CLOSED'}

	@classmethod
	def poll(cls, context):
		return uperf.show_help_panel

	def draw(self, context):
		l = self.layout
		l.scale_y = 1.5
		l.operator(SeamlessOperator_ViewDocs.bl_idname, "View Documentation", icon="QUESTION")

class SeamlessNodeEditorPanel(Panel):
	bl_space_type = 'NODE_EDITOR'
	bl_region_type = 'UI'
	bl_label = "Seamless Tools"

	@classmethod
	def poll(cls, context):
		space = context.space_data
		return space.type == "NODE_EDITOR" and space.tree_type == "ShaderNodeTree"

	def draw(self, context):
		l = self.layout
		c = l.column(True)
		c.operator(SeamlessOperator_LoadNodeGroups.bl_idname, "Load Node Groups", icon="NODETREE")
		c.operator(SeamlessOperator_RefreshNodeGroups.bl_idname, "Refresh Node Groups", icon="FILE_REFRESH")
		g = bpy.data.node_groups
		try: s = g["Seamless Area"].nodes["resolution"].outputs[0]
		except: pass
		else:
			c = l.box().column(True)
			c.label("Approx Object Location:")
			c.prop(s, "default_value", "Resolution")

def particle_refresh(self, context):
	ob = context.object
	is_seamless = False
	try: is_seamless = ob.parent.name == SEAMLESS_OBJECTS_NAME
	except: pass

	psys = context.particle_system
	settings = psys.settings
	if not settings: return

	p = settings.seamless
	l = self.layout
	c = l.column(True)
	c.label("Seamless Settings:")
	b = c.box()
	c = b.column(True)
	if is_seamless and p.mode != p.mode_last:
		r = c.row(True)
		r.label("Reinsertion required!",icon="ERROR")
	r = c.row(True)
	r.prop(p, "mode", "")
	r.operator(SeamlessOperator_RefreshProxyParticleSystem.bl_idname, "Refresh", icon="FILE_REFRESH")

arrow_verts = [
	Vector((0.0, 0.0, 4.0)),
	Vector((0.0, 0.0, 0.0)),

	Vector((0.0, 0.0, 4.0)),
	Vector((0.0, 0.2, 3.8)),

	Vector((0.0, 0.0, 4.0)),
	Vector((0.0, -0.2, 3.8)),

	Vector((0.0, 0.0, 4.0)),
	Vector((0.2, 0.0, 3.8)),

	Vector((0.0, 0.0, 4.0)),
	Vector((-0.2, 0.0, 3.8))
]

area_quads = [
	(Vector((1, 1, 3.8)), 0),
	(Vector((-1, 1, 3.8)), 0),
	(Vector((-1, 1, 0)), 1),
	(Vector((1, 1, 0)), 1),

	(Vector((1, -1, 3.8)), 0),
	(Vector((-1, -1, 3.8)), 0),
	(Vector((-1, -1, 0)), 1),
	(Vector((1, -1, 0)), 1),

	(Vector((1, 1, 3.8)), 0),
	(Vector((1, 1, 0)), 1),
	(Vector((1, -1, 0)), 1),
	(Vector((1, -1, 3.8)), 0),

	(Vector((-1, 1, 3.8)), 0),
	(Vector((-1, 1, 0)), 1),
	(Vector((-1, -1, 0)), 1),
	(Vector((-1, -1, 3.8)), 0),
]

default_mat = Matrix()
cb_handle = None
def draw_callback_seamless(context):
	props = context.scene.seamless
	
	sa = get_seamless_area(context)
	selected = False
	if sa:
		if not context.scene in sa.users_scene:
			return
		vis = False
		sal = sa.layers
		vl = context.scene.layers
		for i, l in enumerate(vl):
			if l and l == sal[i]:
				vis = True
				break
		if not vis:
			return
		mat = sa.matrix_world
		selected = sa.select
	else:
		return

	glDepthMask(GL_FALSE)
	if props.show_proxies:
		proxy_group = get_sp_group()
		if proxy_group:
			col_pr = uperf.col_seamless_proxies
			proxy_objects = proxy_group.objects
			glEnable(GL_BLEND)
			glPointSize(2.0)
			glColor4f(col_pr[0], col_pr[1], col_pr[2], 1.0 if selected else 0.7)
			glBegin(GL_POINTS)
			for proxy in proxy_objects:
				glVertex3f(*proxy.matrix_world.translation)
			glEnd()

	level = 0.2 if selected else 0.1
	if props.show_area:
		col_area = uperf.col_seamless_area

		x = float(props.tile_x)
		y = float(props.tile_y)
		hx = x / 2.0
		hy = y / 2.0

		ox = Vector((hx, hy, 0.0))
		lines = [mat * (vert + ox) for vert in arrow_verts]

		ox[0] = -ox[0]
		lines.extend([mat * (vert + ox) for vert in arrow_verts])

		ox[1] = -ox[1]
		lines.extend([mat * (vert + ox) for vert in arrow_verts])

		ox[0] = -ox[0]
		lines.extend([mat * (vert + ox) for vert in arrow_verts])

		h_bounds = [
			Vector((hx, hy, 0.0)),
			Vector((-hx, hy, 0.0)),
			Vector((hx, -hy, 0.0)),
			Vector((-hx, -hy, 0.0)),
			Vector((hx, hy, 0.0)),
			Vector((hx, -hy, 0.0)),
			Vector((-hx, hy, 0.0)),
			Vector((-hx, -hy, 0.0)),
		]

		lines.extend([mat * vert for vert in h_bounds])

		quads = []
		for vert, value in area_quads:
			vert = vert.copy()
			vert[0] *= hx
			vert[1] *= hy
			quads.append((mat * vert, value))

		glEnable(GL_BLEND)
		glColor4f(col_area[0], col_area[1], col_area[2], 1.0 if selected else 0.5)

		glBegin(GL_LINES)
		for vert in lines:
			glVertex3f(*vert)
		glEnd()

		glBlendFunc(GL_ONE, GL_ONE);
		glShadeModel(GL_SMOOTH);
		area_color = (col_area[0] * level, col_area[1] * level, col_area[2] * level)
		glBegin(GL_QUADS)
		for vert, value in quads:
			if value:
				glColor3f(*area_color)
			else:
				glColor4f(0.0, 0.0, 0.0, 1)
			glVertex3f(*vert)
		glEnd()

		if props.use_margin and props.show_margin and props.margin > 0.001:
			col_margin = uperf.col_seamless_margin
			margin = props.margin
			lines = []
			ox = Vector((hx + margin, hy + margin, 0.0))
			lines = [mat * (vert + ox) for vert in arrow_verts]

			ox[0] = -ox[0]
			lines.extend([mat * (vert + ox) for vert in arrow_verts])

			ox[1] = -ox[1]
			lines.extend([mat * (vert + ox) for vert in arrow_verts])

			ox[0] = -ox[0]
			lines.extend([mat * (vert + ox) for vert in arrow_verts])

			div = 3
			inc = margin / div
			for i in range(div):
				for v in h_bounds:
					if v[0] < 0.0:
						v[0] -= inc
					else:
						v[0] += inc
					if v[1] < 0.0:
						v[1] -= inc
					else:
						v[1] += inc

				lines.extend([mat * vert for vert in h_bounds])
			lines.extend([mat * (vert + Vector((0.0, 0.0, 1.0))) for vert in h_bounds])
			lines.extend([mat * (vert + Vector((0.0, 0.0, 2.0))) for vert in h_bounds])

			quads = []
			for vert, value in area_quads:
				vert = vert.copy()
				vert[0] *= hx + margin
				vert[1] *= hy + margin
				vert[2] *= 0.5
				quads.append((mat * vert, value))

			glColor4f(col_margin[0], col_margin[1], col_margin[2], 1.0 if selected else 0.5)
	
			glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)
			glBegin(GL_LINES)
			for vert in lines:
				glVertex3f(*vert)
			glEnd()

			glBlendFunc(GL_ONE, GL_ONE);
			glShadeModel(GL_SMOOTH);
			area_color = (col_margin[0] * level, col_margin[1] * level, col_margin[2] * level)
			glBegin(GL_QUADS)
			for vert, value in quads:
				if value:
					glColor3f(*area_color)
				else:
					glColor4f(0.0, 0.0, 0.0, 1)
				glVertex3f(*vert)
			glEnd()

		if props.use_floor and props.show_floor:
			col_floor = uperf.col_seamless_floor
			lines = []
			floor = props.floor
			margin = props.margin if props.use_margin else 0
			div = 4
			hhx = hx + margin
			hhy = hy + margin
			inc_x = (hhx * 2) / div
			inc_y = (hhy * 2) / div
			for i in range(div + 1):
				value = (inc_x * i) - hhx
				lines.extend([
					mat * Vector((value, hhy, floor)),
					mat * Vector((value, -hhy, floor)),
					])
			for i in range(div + 1):
				value = (inc_y * i) - hhy
				lines.extend([
					mat * Vector((hhx, value, floor)),
					mat * Vector((-hhx, value, floor)),
					])

			quads = [
				mat * Vector((hhx, hhy, floor)),
				mat * Vector((-hhx, hhy, floor)),
				mat * Vector((-hhx, -hhy, floor)),
				mat * Vector((hhx, -hhy, floor)),
			]

			glColor4f(col_floor[0], col_floor[1], col_floor[2], 1.0 if selected else 0.5)
	
			glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)
			glBegin(GL_LINES)
			for vert in lines:
				glVertex3f(*vert)
			glEnd()

			glBlendFunc(GL_ONE, GL_ONE);
			area_color = (col_floor[0] * level, col_floor[1] * level, col_floor[2] * level)
			glColor3f(*area_color)
			glBegin(GL_QUADS)
			for vert in quads:
				glVertex3f(*vert)
			glEnd()

	glDepthMask(GL_TRUE)

# Init Stuff
def install_draw_callback(scene):
	bpy.app.handlers.scene_update_post.remove(install_draw_callback)
	global cb_handle
	cb_handle = bpy.types.SpaceView3D.draw_handler_add(draw_callback_seamless, (bpy.context,), 'WINDOW', 'POST_VIEW')

def register():
	bpy.app.handlers.scene_update_post.append(install_draw_callback)
	bpy.utils.register_module(__name__)
	global uperf
	uperf = bpy.context.user_preferences.addons[__name__].preferences
	bpy.types.PARTICLE_PT_context_particles.append(particle_refresh)

def unregister():
	bpy.types.PARTICLE_PT_context_particles.remove(particle_refresh)
	if cb_handle != None:
		bpy.types.SpaceView3D.draw_handler_remove(cb_handle, 'WINDOW')
	bpy.utils.unregister_module(__name__)

if __name__ == "__main__":
	register()